<!DOCTYPE html>
<!--
  ============================================
  M-PRO Application
  ============================================
  📋 Структура файла: см. bmw.html.txt
     - HTML/CSS разметка
     - JavaScript модули
     - Триггеры и коннективити
  ============================================
-->
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>M-PRO</title>
    
    <!-- v2.1 - принудительное обновление -->
    <script src="https://api-maps.yandex.ru/2.1/?apikey=52007aca-39bd-4a9c-87ef-4d9b730aeb71&lang=ru_RU"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --app-height: 100dvh;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
        }

        html, body {
            width: 100%;
            height: 100%;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: var(--app-height, 100vh);
            overflow: hidden;
            background: #f2f2f7;
        }
        
        .container {
            display: flex;
            height: var(--app-height, 100vh);
        }
        
        /* Боковая панель */
        .sidebar {
            width: 400px;
            min-width: 400px;
            height: var(--app-height, 100vh);
            background: #f2f2f7;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        /* Логотип */
        .logo-container {
            text-align: center;
            padding: 8px 0 16px;
        }
        
        .logo {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #1f6fb2 0%, #3498db 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Карточка пользователя */
        .user-card {
            background: white;
            border-radius: 10px;
            padding: 10px 14px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            font-size: 14px;
        }
        
        .user-role { font-weight: 700; color: #1c1c1e; }
        .user-name { color: #8e8e93; }

        .workday-section {}

        .workday-control-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: white;
            border-radius: 12px;
            padding: 10px 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .workday-status-box {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
        }

        .workday-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #9aa0a6;
            box-shadow: 0 0 0 0 rgba(154, 160, 166, 0.35);
            flex-shrink: 0;
        }

        .workday-status-dot.pending {
            animation: workdayPulseGray 1.6s infinite;
        }

        .workday-status-dot.open {
            background: #27ae60;
            box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.35);
            animation: workdayPulseGreen 1.6s infinite;
        }

        .workday-status-dot.closed {
            background: #7f8c8d;
            box-shadow: 0 0 0 0 rgba(127, 140, 141, 0.25);
        }

        @keyframes workdayPulseGray {
            0% { box-shadow: 0 0 0 0 rgba(154, 160, 166, 0.35); }
            70% { box-shadow: 0 0 0 6px rgba(154, 160, 166, 0); }
            100% { box-shadow: 0 0 0 0 rgba(154, 160, 166, 0); }
        }

        @keyframes workdayPulseGreen {
            0% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.35); }
            70% { box-shadow: 0 0 0 6px rgba(39, 174, 96, 0); }
            100% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0); }
        }

        .workday-status-info {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .workday-status-label {
            font-size: 11px;
            font-weight: 600;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            line-height: 1.1;
        }

        .workday-status-text {
            margin-top: 3px;
            font-size: 14px;
            font-weight: 700;
            color: #4b5563;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .workday-switch {
            position: relative;
            width: 46px;
            height: 28px;
            flex-shrink: 0;
        }

        .workday-switch-input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .workday-switch-track {
            position: absolute;
            inset: 0;
            background: #d1d5db;
            border-radius: 999px;
            transition: background 0.2s ease;
            cursor: pointer;
        }

        .workday-switch-track::before {
            content: "";
            position: absolute;
            left: 2px;
            top: 2px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
            transition: transform 0.2s ease;
        }

        .workday-switch-input:checked + .workday-switch-track {
            background: #34c759;
        }

        .workday-switch-input:checked + .workday-switch-track::before {
            transform: translateX(18px);
        }

        .workday-switch-input:disabled + .workday-switch-track {
            opacity: 0.55;
            cursor: default;
        }

        .inspector-messages-group {
            padding: 10px 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .inspector-message-block {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 8px 10px;
        }

        .inspector-message-block-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #6b7280;
            margin-bottom: 6px;
        }

        .inspector-message-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .inspector-message-item {
            font-size: 13px;
            line-height: 1.35;
            color: #1f2937;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            padding: 7px 8px;
            word-break: break-word;
        }

        .inspector-message-item--empty {
            color: #9ca3af;
            font-style: italic;
            text-align: center;
            border-style: dashed;
        }
        
        /* Секции в стиле iOS */
        .ios-section { margin-bottom: 16px; }
        
        .ios-section-title {
            font-size: 11px;
            font-weight: 600;
            color: #6e6e73;
            margin-bottom: 6px;
            padding-left: 12px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .ios-group {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* Кнопки административных действий */
        .ios-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 10px 14px;
            background: white;
            border: none;
            border-bottom: 1px solid #e5e5ea;
            font-size: 13px;
            color: #111;
            cursor: pointer;
            text-align: left;
        }
        
        .ios-btn:last-child { border-bottom: none; }
        .ios-btn:hover { background: #f9f9fb; }
        .ios-btn-emoji { font-size: 18px; width: 26px; text-align: center; flex-shrink: 0; }
        
        /* Заголовки секций фильтров */
        .filter-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: #f8fafc;
            cursor: pointer;
            border-bottom: 1px solid #e5e5ea;
        }
        
        .filter-header-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            font-size: 14px;
            color: #111;
        }
        
        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #8e8e93;
            cursor: pointer;
        }
        
        .filter-checkbox input {
            width: 18px;
            height: 18px;
            accent-color: #007aff;
        }
        
        .filter-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .filter-content.open {
            max-height: var(--filter-open-max-height, 62vh);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .filter-list { padding: 4px 0; }
        
        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            font-size: 13px;
            cursor: pointer;
        }
        
        .filter-item:hover { background: #f9f9fb; }
        .filter-item input { width: 16px; height: 16px; accent-color: #007aff; }
        
        /* ============================================
           НИЖНЕЕ МЕНЮ (СТЕКЛЯННЫЙ ЭФФЕКТ)
           ============================================ */
        .modern-menu-container {
            margin-top: auto;
            padding: 10px 0;
            position: sticky;
            bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px) saturate(140%);
            -webkit-backdrop-filter: blur(10px) saturate(140%);
            z-index: 100;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .modern-menu {
            display: flex;
            background: rgba(240, 242, 245, 0.35);
            border-radius: 16px;
            padding: 4px;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.05);
            position: relative;
        }
        
        .modern-menu::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 16px;
            background-image: radial-gradient(rgba(255, 255, 255, 0.12) 1px, transparent 1px);
            background-size: 6px 6px;
            opacity: 0.25;
            pointer-events: none;
        }
        
        .menu-indicator {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: 25%;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px) saturate(160%) contrast(105%);
            -webkit-backdrop-filter: blur(8px) saturate(160%) contrast(105%);
            border: 1px solid rgba(255, 255, 255, 0.55);
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08), inset 0 0 14px rgba(255, 255, 255, 0.18);
            transition: all 0.25s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 3;
            pointer-events: auto;
            cursor: grab;
            overflow: hidden;
            touch-action: none;
        }
        
        .menu-indicator:active {
            cursor: grabbing;
        }
        

        
        .menu-indicator-inner {
            position: absolute;
            top: -4px;
            left: -4px;
            width: 100%;
            height: calc(100% + 8px);
            display: flex;
            padding: 4px;
            box-sizing: border-box;
            pointer-events: none;
            will-change: transform;
            transition: left 0.25s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        .lens-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #3498db;
            font-weight: 700;
            transition: none;
        }
        
        .lens-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
            transform: scale(1.1);
        }
        
        .lens-btn .modern-menu-label {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }
        
        .modern-menu-btn {
            flex: 1;
            border: none;
            background: transparent;
            padding: 10px 0;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #95a5a6 !important;
            transition: color 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            z-index: 2;
        }
        
        .modern-menu-btn:hover {
            color: #7f8c8d;
        }
        
        .modern-menu-btn.active {
            color: #95a5a6 !important;
            font-weight: 700;
            background: transparent;
            box-shadow: none;
            transform: none;
        }
        
        .modern-menu-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
            transform: none !important;
        }
        
        .modern-menu-btn.active svg {
            transform: scale(1.1);
        }
        
        .modern-menu-label {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }
        
        /* Карта */
        .map-container { flex: 1; position: relative; }
        #map { width: 100%; height: 100%; }

        .map-inline-search {
            display: none;
        }

        .map-inline-search__box {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.94);
            border: 1px solid rgba(255, 255, 255, 0.7);
            border-radius: 14px;
            padding: 8px 10px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.22);
            backdrop-filter: blur(8px) saturate(120%);
            -webkit-backdrop-filter: blur(8px) saturate(120%);
        }

        .map-inline-search__input {
            flex: 1;
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            color: #1f2937;
            min-width: 0;
        }

        .map-inline-search__input::placeholder {
            color: #6b7280;
        }

        .map-inline-search__btn {
            border: none;
            background: #eef2f7;
            color: #1f2937;
            border-radius: 10px;
            padding: 7px 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
        }

        .map-inline-search__btn:active {
            transform: scale(0.98);
        }

        .map-inline-search__btn--close {
            width: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .map-inline-search__close-arrow {
            display: block;
            font-size: 18px;
            line-height: 1;
            animation: mapInlineSearchArrowPulse 1.25s ease-in-out infinite;
        }

        @keyframes mapInlineSearchArrowPulse {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(2px); }
        }
        
        /* Боковая панель (выезжает слева) */
        .side-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 400px;
            height: var(--app-height, 100vh);
            background: white;
            box-shadow: 2px 0 20px rgba(0,0,0,0.3);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            transform: translateX(0);
            transition: transform 0.3s ease;
        }
        
        .side-panel.hidden { transform: translateX(-100%); }
        
        .side-panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5ea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }
        
        .side-panel-header h3 { margin: 0; font-size: 13px; font-weight: 600; white-space: nowrap; }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #8e8e93;
        }
        
        .side-panel-search {
            padding: 12px 16px;
            border-bottom: 1px solid #e5e5ea;
        }
        
        .side-panel-search input {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #e5e5ea;
            border-radius: 10px;
            font-size: 14px;
        }
        
        .side-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .mobile-sidebar-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.28);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 1098;
        }

        .mobile-sidebar-backdrop.visible {
            opacity: 1;
        }

        .mobile-fab-menu {
            display: none;
            position: fixed;
            right: 20px;
            right: calc(20px + var(--safe-right));
            bottom: 20px;
            bottom: calc(20px + var(--safe-bottom));
            width: 56px;
            height: 56px;
            z-index: 1100;
            overflow: visible;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }

        .mobile-fab-menu .map-inline-search {
            position: absolute;
            right: 0;
            bottom: 0;
            width: min(300px, calc(100vw - 96px));
            opacity: 0;
            pointer-events: none;
            transform: translateX(0) scale(0.92);
            transform-origin: right center;
            transition: transform 0.24s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.2s ease;
            z-index: 1099;
            display: block;
        }

        .mobile-fab-menu .map-inline-search__box {
            min-height: 56px;
            border-radius: 18px;
            padding: 8px 10px;
        }

        .mobile-fab-menu.mobile-fab-menu--search-open .map-inline-search {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-68px) scale(1);
        }

        .mobile-fab-action {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 56px;
            height: 56px;
            border: 1px solid rgba(255, 255, 255, 0.65);
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1f2937;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transform: translateX(0) scale(0.72);
            transition: transform 0.24s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-fab-action svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .mobile-fab-menu.mobile-fab-menu--expanded .mobile-fab-action {
            opacity: 1;
            pointer-events: auto;
        }

        .mobile-fab-menu.mobile-fab-menu--expanded .mobile-fab-action--menu {
            transform: translateX(-64px) scale(1);
        }

        .mobile-fab-menu.mobile-fab-menu--expanded .mobile-fab-action--search {
            transform: translateX(-128px) scale(1);
        }

        .mobile-fab-menu.mobile-fab-menu--search-open .mobile-fab-action {
            opacity: 0;
            pointer-events: none;
            transform: translateX(0) scale(0.72);
        }

        .mobile-sidebar-open .mobile-fab-menu {
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }

        .mobile-hamburger {
            display: flex;
            position: absolute;
            inset: 0;
            width: 56px;
            height: 56px;
            border: 1px solid rgba(255, 255, 255, 0.65);
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.92);
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.22);
            backdrop-filter: blur(8px) saturate(125%);
            -webkit-backdrop-filter: blur(8px) saturate(125%);
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1100;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-hamburger:active {
            transform: scale(0.97);
        }

        .mobile-hamburger__bars,
        .mobile-hamburger__bars::before,
        .mobile-hamburger__bars::after {
            width: 22px;
            height: 2px;
            border-radius: 2px;
            background: #1f2937;
            transition: transform 0.22s ease, opacity 0.22s ease;
        }

        .mobile-hamburger__bars {
            position: relative;
            display: block;
        }

        .mobile-hamburger__bars::before,
        .mobile-hamburger__bars::after {
            content: "";
            position: absolute;
            left: 0;
        }

        .mobile-hamburger__bars::before {
            top: -7px;
        }

        .mobile-hamburger__bars::after {
            top: 7px;
        }

        .mobile-hamburger.active .mobile-hamburger__bars {
            background: transparent;
        }

        .mobile-hamburger.active .mobile-hamburger__bars::before {
            transform: translateY(7px) rotate(45deg);
        }

        .mobile-hamburger.active .mobile-hamburger__bars::after {
            transform: translateY(-7px) rotate(-45deg);
        }
        
        .inspector-section-title {
            font-size: 12px;
            font-weight: 700;
            color: #6e6e73;
            text-transform: uppercase;
            margin: 16px 0 8px;
            padding-left: 8px;
        }
        
        .inspector-section-title:first-child { margin-top: 0; }
        
        .inspector-list { display: flex; flex-direction: column; gap: 8px; }
        
        .inspector-card {
            background: white;
            border: 1px solid #e5e5ea;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .inspector-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            background: #f8f9fa;
        }
        
        .inspector-card-header:hover { background: #f2f2f7; }
        
        .inspector-emoji { font-size: 24px; width: 32px; text-align: center; }
        .inspector-name { flex: 1; font-weight: 600; font-size: 15px; }
        .inspector-badges {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .inspector-workday-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3b30;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
        }
        .inspector-workday-dot.open { background: #34c759; }
        .inspector-workday-dot.closed { background: #ff3b30; }
        
        .inspector-card-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 16px;
        }
        
        .inspector-card.open .inspector-card-content {
            max-height: 500px;
            padding: 16px;
            border-top: 1px solid #e5e5ea;
            overflow-y: auto;
        }
        
        .control-group { margin-bottom: 16px; }
        .control-group:last-child { margin-bottom: 0; }
        
        .control-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #6e6e73;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        /* Стили раскрывающихся пикеров */
        .picker-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: white;
            border: 1px solid #e5e5ea;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .picker-toggle:hover {
            background: #f9f9fb;
        }
        
        .picker-toggle-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .picker-toggle-arrow {
            transition: transform 0.3s ease;
            font-size: 12px;
        }
        
        .picker-toggle.open .picker-toggle-arrow {
            transform: rotate(180deg);
        }
        
        .picker-preview-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #e5e5ea;
        }
        
        .picker-preview-icon {
            font-size: 20px;
        }
        
        .picker-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            margin-top: 8px;
        }
        
        .picker-dropdown.open {
            max-height: 200px;
        }
        
        .status-options {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .status-option {
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .status-option:hover {
            background: #e5e5ea;
        }
        
        .status-option.active {
            background: #007aff;
            color: white;
        }
        
        .color-picker {
            display: none;
        }

        .color-custom-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
            padding: 2px 2px 8px;
            border-bottom: 1px solid #eef2f7;
        }

        .color-custom-label {
            font-size: 12px;
            color: #64748b;
            font-weight: 600;
        }

        .color-custom-input {
            width: 40px;
            height: 28px;
            border: 1px solid #dbe2ea;
            border-radius: 8px;
            padding: 0;
            background: #fff;
            cursor: pointer;
        }
        
        .color-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            position: relative;
        }
        
        .color-dot:hover {
            transform: scale(1.15);
            z-index: 1;
        }
        
        .color-dot.active { 
            border-color: #007aff;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #007aff;
        }
        
        .icon-picker {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
            max-height: 180px;
            overflow-y: auto;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .icon-option {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 8px;
            cursor: pointer;
            background: white;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .icon-option:hover { 
            background: #e5e5ea;
            transform: scale(1.1);
        }
        .icon-option.active { 
            background: #007aff; 
            color: white;
            border-color: #0056b3;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
        }

        .picker-more-btn {
            margin-top: 8px;
            width: 100%;
            padding: 9px 10px;
            border: 1px solid #d6d9e0;
            border-radius: 9px;
            background: #ffffff;
            color: #475569;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .picker-more-btn:hover {
            background: #f3f4f6;
        }
        
        .status-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e5e5ea;
            border-radius: 8px;
            font-size: 14px;
            background: white;
        }
        
        .apply-btn {
            width: 100%;
            padding: 12px;
            background: #007aff;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 12px;
            transition: background-color 0.3s ease;
        }
        
        .apply-btn:hover { 
            background: #0056b3;
        }
        
        .apply-btn.saving {
            background: #5856d6;
        }
        
        .apply-btn.saved {
            background: #34c759;
        }
        
        /* ============================================
           СТИЛИ АККОРДЕОНОВ
           ============================================ */
        .accordion {
            border-bottom: 1px solid #e5e5ea;
            background: white;
        }
        
        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            background: #f8fafc;
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
        }
        
        .accordion-header:hover {
            background: #f2f2f7;
        }
        
        .accordion-title {
            font-weight: 600;
            font-size: 14px;
            color: #1c1c1e;
        }
        
        .accordion-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #8e8e93;
            font-size: 13px;
        }

        .accordion-arrow {
            display: inline-flex;
            transform-origin: center;
            transition: transform 0.2s;
        }
        
        .inspector-counter {
            background: #e5e5ea;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #6e6e73;
        }
        
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        .accordion-content.active {
            max-height: min(58vh, 520px);
            border-bottom: 1px solid #e5e5ea;
            transition: max-height 0.5s ease-in;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* Элементы списка с чекбоксами */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #f2f2f7;
        }
        
        .checkbox-item:last-child {
            border-bottom: none;
        }
        
        .checkbox-item:hover {
            background: #f9f9fb;
        }
        
        .checkbox-item input[type="checkbox"],
        .blue-checkbox {
            width: 18px;
            height: 18px;
            accent-color: #007aff;
            cursor: pointer;
            margin: 0;
        }
        
        .checkbox-item label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            color: #1c1c1e;
            user-select: none;
            line-height: 1.4;
        }
        
        .select-all-item {
            background: #f0f2f5;
            font-weight: 600;
        }

        /* Вкладка «Объекты» и нижний поиск */
        #nav-objects.nav-pane {
            display: none;
        }

        #nav-objects.nav-pane.active {
            display: block;
        }

        .modern-search-wrapper {
            display: none;
            margin: 0 2px;
        }

        .modern-search-box {
            display: flex;
            align-items: center;
            gap: 10px;
            border-radius: 999px;
            padding: 10px 16px;
            background: #e7eaee;
            border: 1px solid #dde2e8;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .modern-search-icon {
            color: #4aa3df;
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modern-search-input {
            width: 100%;
            border: none;
            background: transparent;
            outline: none;
            font-size: 15px;
            color: #334155;
            padding: 4px 0;
        }

        .modern-search-input::placeholder {
            color: #8a9aa6;
        }

        .objects-list {
            overflow-y: auto;
        }

        .accordion-content.objects-list.active {
            max-height: 280px;
        }

        .objects-active-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-right: 8px;
            font-size: 13px;
            color: #1c1c1e;
            user-select: none;
            cursor: pointer;
        }

        .objects-active-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            accent-color: #007aff;
            cursor: pointer;
        }

        .objects-list-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 14px;
            border-bottom: 1px solid #f2f2f7;
            background: #fff;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .objects-list-item:hover {
            background: #f8fafc;
        }

        .objects-list-item:last-child {
            border-bottom: none;
        }

        .objects-list-item__main {
            flex: 1;
            min-width: 0;
        }

        .objects-list-item__title {
            font-size: 13px;
            font-weight: 700;
            color: #1c1c1e;
            line-height: 1.2;
        }

        .objects-list-item__sub {
            margin-top: 3px;
            font-size: 12px;
            color: #6e6e73;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .objects-list-empty {
            padding: 14px;
            text-align: center;
            color: #8e8e93;
            font-size: 13px;
        }
         
        /* ============================================
           МОДАЛЬНОЕ ОКНО ДЕТАЛЕЙ ОБЪЕКТА (КАСТОМНЫЙ БАЛУН)
           ============================================ */
        .object-details {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }
        
        .object-details--visible { display: flex; }
        .object-details.hidden { display: none; }
        
        .object-details__backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
        }
        
        .object-details__card {
            position: relative;
            background: #ffffff;
            border-radius: 22px;
            width: min(560px, 96vw);
            max-height: 90vh;
            overflow: hidden;
            padding: 30px 32px 34px;
            box-shadow: 0 28px 60px rgba(0, 0, 0, 0.25);
            z-index: 1;
            animation: objectDetailsIn 0.25s ease;
        }
        
        .object-details__content {
            max-height: calc(90vh - 90px);
            overflow-y: auto;
            margin-top: 12px;
            padding-right: 24px;
            scrollbar-gutter: stable;
        }
        
        .object-details__content::-webkit-scrollbar { width: 0; height: 0; }
        
        .object-details__close {
            position: absolute;
            top: 18px;
            right: 18px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: #f2f4f8;
            color: #2c3e50;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease, transform 0.2s ease;
        }
        
        .object-details__close:hover { background: #e3e6ed; transform: scale(1.05); }
        
        body.object-details-open { overflow: hidden; }
        
        @keyframes objectDetailsIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Стили карточки объекта */
        .object-card {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .object-card__header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            position: relative;
        }
        
        .object-card__title {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .object-card__emoji { font-size: 24px; }
        
        .object-card__name {
            font-size: 1.1rem;
            font-weight: 700;
            color: #2c3e50;
            line-height: 1.3;
        }
        
        .object-card__meta {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 2px;
        }
        
        .object-card__badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .object-card__badge--new {
            background: #fff5f5;
            color: #c53030;
            border: 1px solid #feb2b2;
        }
        
        .object-card__badge--active {
            background: #ebf8ff;
            color: #2b6cb0;
            border: 1px solid #90cdf4;
        }
        
        .object-card__badge--completed {
            background: #f0fff4;
            color: #276749;
            border: 1px solid #9ae6b4;
        }
        
        .object-card__badge--denied {
            background: #fff5f5;
            color: #c53030;
            border: 1px solid #feb2b2;
        }
        
        .object-card__info {
            display: grid;
            gap: 8px;
            background: #f7fafc;
            padding: 12px 14px;
            border-radius: 12px;
        }
        
        .object-card__row {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .object-card__label {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: #a0aec0;
            letter-spacing: 0.03em;
            font-weight: 600;
        }
        
        .object-card__value {
            font-size: 0.9rem;
            color: #2d3748;
            font-weight: 500;
            line-height: 1.3;
        }
        
        .object-card__actions {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 0;
            background: #ffffff;
            border: 1px solid #dbe4ef;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .object-card__button {
            flex: 1 1 100%;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            padding: 10px 12px;
            border: none;
            background: #ffffff;
            color: #253447;
            font-size: 0.9rem;
            font-weight: 600;
            border-bottom: 1px solid #edf2f7;
            cursor: pointer;
            transition: background 0.15s ease;
            text-decoration: none;
            font-family: inherit;
            -webkit-font-smoothing: antialiased;
        }

        .object-card__button-emoji {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            flex: 0 0 20px;
            font-size: 16px;
            line-height: 1;
            font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
        }

        .object-card__button-text {
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            line-height: 1.25;
            letter-spacing: 0;
        }
        
        .object-card__button:last-child {
            border-bottom: none;
        }

        .object-card__button:hover {
            background: #f4f8fc;
        }
        
        /* Специальные стили для кнопок действий в карточке деталей объекта */
        .object-card__button--primary,
        .object-card__button--success,
        .object-card__button--warning,
        .object-card__button--danger,
        .object-card__button--accent {
            color: #2d3748;
        }
        
        .object-card__section--reassign {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 20px;
        }

        .object-card__section--reassign .object-card__label {
            margin-bottom: 6px;
        }
        
        .object-card__select {
            width: 100%;
            border-radius: 12px;
            border: 1px solid #dfe6e9;
            padding: 12px;
            font-size: 0.9rem;
            background: #ffffff;
            color: #2c3e50;
            font-family: inherit;
            font-weight: 500;
            -webkit-font-smoothing: antialiased;
        }
        
        .object-card__spacer { height: 20px; flex: 0 0 auto; }
        
        /* ============================================
           СТЕКЛЯННЫЕ УВЕДОМЛЕНИЯ (ОДИН АКТИВНЫЙ ЭКЗЕМПЛЯР)
           ============================================ */
        .glass-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px) scale(0.9);
            z-index: 999999;
            
            /* Стеклянный эффект, визуально согласованный с индикатором нижнего меню */
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(20px) saturate(180%) contrast(105%);
            -webkit-backdrop-filter: blur(20px) saturate(180%) contrast(105%);
            
            /* Граница в том же стиле, что и у индикатора нижнего меню */
            border: 1px solid rgba(255, 255, 255, 0.55);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            
            /* Тень в том же стиле, что и у индикатора нижнего меню */
            box-shadow:
                0 8px 18px rgba(0, 0, 0, 0.08),
                inset 0 0 14px rgba(255, 255, 255, 0.18);
            
            color: #1f2937;
            padding: 14px 28px;
            border-radius: 16px;
            font-size: 0.95rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            
            pointer-events: auto;
            cursor: grab;
            user-select: none;
            min-width: 280px;
            max-width: 90vw;
            
            opacity: 0;
            transition: 
                transform 0.4s cubic-bezier(0.25, 1, 0.5, 1),
                opacity 0.3s ease;
        }
        
        .glass-notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }
        
        .glass-notification.swipe-out {
            opacity: 0;
            transform: translateX(-50%) translateY(-80px) scale(0.95);
        }
        

        
        .glass-notification-icon {
            font-size: 1.3rem;
            flex-shrink: 0;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .glass-notification-text {
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
        }
        
        /* Специальные стили для блока кнопки Яндекс.Диска в карточке объекта */
        .yandex-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: currentColor;
            border-radius: 50%;
            animation: yandex-spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 6px;
        }
        
        @keyframes yandex-spin {
            to { transform: rotate(360deg); }
        }
        
        .yandex-progress-container {
            margin-top: 8px;
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .yandex-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .empty, .loading {
            text-align: center;
            padding: 40px;
            color: #8e8e93;
        }
        
        /* Стили экрана авторизации */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        
        .auth-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .auth-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 48px 40px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
            animation: authSlideIn 0.6s ease;
        }
        
        @keyframes authSlideIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .auth-logo {
            margin-bottom: 24px;
        }
        
        .auth-logo-icon {
            font-size: 56px;
            margin-bottom: 12px;
            animation: authPulse 2s ease infinite;
        }
        
        @keyframes authPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .auth-logo-text {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #1f6fb2 0%, #3498db 50%, #2ecc71 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .auth-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1c1c1e;
            margin-bottom: 8px;
        }
        
        .auth-subtitle {
            font-size: 0.95rem;
            color: #6e6e73;
            margin-bottom: 32px;
        }
        
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .auth-input-group {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .auth-input-icon {
            position: absolute;
            left: 16px;
            font-size: 18px;
            z-index: 1;
        }
        
        .auth-input {
            width: 100%;
            padding: 16px 16px 16px 48px;
            border: 2px solid #e5e5ea;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 500;
            color: #1c1c1e;
            background: white;
            transition: all 0.3s ease;
            outline: none;
        }
        
        .auth-input:focus {
            border-color: #007aff;
            box-shadow: 0 0 0 4px rgba(0, 122, 255, 0.15);
        }
        
        .auth-input.error {
            border-color: #ff3b30;
            animation: authShake 0.5s ease;
        }

        .auth-remember {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #5f6368;
            user-select: none;
            cursor: pointer;
        }

        .auth-remember input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #1976d2;
        }
        
        @keyframes authShake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-10px); }
            40%, 80% { transform: translateX(10px); }
        }
        
        .auth-btn {
            position: relative;
            width: 100%;
            padding: 16px 24px;
            background: linear-gradient(135deg, #007aff 0%, #0056b3 100%);
            color: white;
            border: none;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .auth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px -5px rgba(0, 122, 255, 0.4);
        }
        
        .auth-btn:active {
            transform: translateY(0);
        }
        
        .auth-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        
        .auth-btn.loading .auth-btn-text {
            opacity: 0;
        }
        
        .auth-btn-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            opacity: 0;
            animation: authSpin 0.8s linear infinite;
        }
        
        .auth-btn.loading .auth-btn-loader {
            opacity: 1;
        }
        
        @keyframes authSpin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .auth-error {
            min-height: 24px;
            margin-top: 12px;
            font-size: 14px;
            color: #ff3b30;
            font-weight: 500;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }
        
        .auth-error.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .auth-hint {
            margin-top: 24px;
            padding: 12px 16px;
            background: #f2f2f7;
            border-radius: 10px;
            font-size: 13px;
            color: #6e6e73;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .auth-hint-icon {
            font-size: 14px;
        }

        @media (max-width: 980px) {
            .container {
                display: block;
                height: var(--app-height, 100dvh);
            }

            .map-container {
                width: 100%;
                height: var(--app-height, 100dvh);
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                min-width: 0;
                height: var(--app-height, 100dvh);
                transform: translateX(-110%);
                transition: transform 0.28s cubic-bezier(0.16, 1, 0.3, 1);
                box-shadow: 10px 0 30px rgba(15, 23, 42, 0.28);
                z-index: 1099;
            }

            .sidebar.sidebar--mobile-open {
                transform: translateX(0);
            }

            .sidebar-content {
                padding: 12px;
            }

            .modern-menu-container {
                padding: 8px 0 calc(8px + env(safe-area-inset-bottom));
                gap: 6px;
            }

            .modern-menu-btn {
                padding: 8px 0;
            }

            .modern-menu-btn svg {
                width: 22px;
                height: 22px;
            }

            .object-details__card {
                width: min(95vw, 560px);
                max-height: 92dvh;
                border-radius: 18px;
                padding: 20px 18px 22px;
            }

            .object-details__content {
                max-height: calc(92dvh - 80px);
                padding-right: 6px;
            }

            .side-panel {
                width: min(92vw, 400px);
            }

            .mobile-fab-menu {
                display: block;
            }
        }


    </style>
</head>
<body>
    <!-- Object Details Modal (Custom Balloon) -->
    <div class="object-details hidden" id="objectDetailsOverlay">
        <div class="object-details__backdrop" data-action="close-object-details"></div>
        <div class="object-details__card" role="dialog" aria-modal="true">
            <button class="object-details__close" type="button" data-action="close-object-details">✕</button>
            <div class="object-details__content" id="objectDetailsContent"></div>
        </div>
    </div>

    <!-- Оверлей авторизации (скрыт по умолчанию, показывается через JS если не авторизован) -->
    <div id="authOverlay" class="auth-overlay hidden">
        <div class="auth-container">
            <div class="auth-logo">
                <div class="auth-logo-icon">🔐</div>
                <div class="auth-logo-text">m-pro</div>
            </div>
            <div class="auth-title">Авторизация</div>
            <div class="auth-subtitle">Введите ваш пароль для входа</div>
            
            <div class="auth-form">
                <div class="auth-input-group">
                    <span class="auth-input-icon">🔑</span>
                    <input type="password" id="authPassword" class="auth-input" placeholder="Пароль" maxlength="20">
                </div>
                <label class="auth-remember" for="authRemember">
                    <input type="checkbox" id="authRemember" checked>
                    <span>Запомнить вход</span>
                </label>
                <button class="auth-btn" data-action="login">
                    <span class="auth-btn-text">Войти</span>
                    <span class="auth-btn-loader"></span>
                </button>
            </div>
            
            <div class="auth-error" id="authError"></div>
            
            <div class="auth-hint">
                <span class="auth-hint-icon">💡</span>
                <span>Пароль выдаётся администратором</span>
            </div>
        </div>
    </div>
    <div class="container">
        <!-- SIDEBAR -->
        <aside class="sidebar" id="mainSidebar">
            <div class="sidebar-content">
                <div id="nav-lists">
                    <!-- Logo -->
                    <div class="logo-container">
                        <div class="logo">m-pro</div>
                    </div>
                    
                    <!-- User -->
                    <div class="user-card">
                        <span class="user-emoji">👤</span>
                        <div>
                            <span class="user-role">Администратор:</span>
                            <span class="user-name">Admin</span>
                        </div>
                    </div>

                    <div class="ios-section workday-section" id="workDaySection">
                        <div class="workday-control-card" id="workDayControlWrapper">
                            <div class="workday-status-box">
                                <div class="workday-status-dot pending" id="workDayStatusDot"></div>
                                <div class="workday-status-info">
                                    <div class="workday-status-label">Рабочий день</div>
                                    <div class="workday-status-text" id="workDayStatusText">Синхронизация...</div>
                                </div>
                            </div>
                            <div class="workday-switch">
                                <input
                                    type="checkbox"
                                    id="workDayToggle"
                                    class="workday-switch-input"
                                    data-change-action="toggle-workday"
                                    disabled
                                >
                                <label for="workDayToggle" class="workday-switch-track"></label>
                            </div>
                        </div>
                    </div>

                    <div class="ios-section inspector-messages-section" id="inspectorMessagesSection">
                        <div class="ios-section-title">🔔 Уведомления</div>
                        <div class="ios-group inspector-messages-group">
                            <div class="inspector-message-block">
                                <div class="inspector-message-block-title">Индивидуальные</div>
                                <div class="inspector-message-list" id="inspectorMessagesIndividual"></div>
                            </div>
                            <div class="inspector-message-block">
                                <div class="inspector-message-block-title">Групповые</div>
                                <div class="inspector-message-list" id="inspectorMessagesGroup"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Admin Functions -->
                    <div class="ios-section" id="adminFunctionsSection">
                        <div class="ios-section-title">⚙️ Административные функции</div>
                        <div class="ios-group">
                            <button class="ios-btn" data-action="show-homes">
                                <span class="ios-btn-emoji">🏠</span>
                                <span>Домашние адреса</span>
                            </button>
                            <button class="ios-btn" data-action="show-inspector-management">
                                <span class="ios-btn-emoji">🧭</span>
                                <span>Кастомизация и управление инспекторами</span>
                            </button>
                            <button class="ios-btn" data-action="archive-completed">
                                <span class="ios-btn-emoji">🗄️</span>
                                <span>Архивировать выполненные</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Filters -->
                    <div class="ios-section">
                        <div class="ios-group">
                            <!-- Object Lists -->
                            <div class="filter-header" data-action="toggle-filter" data-filter-id="lists">
                                <div class="filter-header-content">
                                    <span>📋</span>
                                    <span>Списки объектов</span>
                                </div>
                            </div>
                            <div class="filter-content" id="filter-lists">
                                <div class="filter-list" id="lists-container">
                                    <div class="filter-item">
                                        <input type="checkbox" id="list-1">
                                        <label for="list-1">Загрузка...</label>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Inspector Lists -->
                            <div class="filter-header" data-action="toggle-filter" data-filter-id="inspectors">
                                <div class="filter-header-content">
                                    <span>👥</span>
                                    <span>Списки инспекторов</span>
                                </div>
                            </div>
                            <div class="filter-content" id="filter-inspectors">
                                <div class="filter-list" id="inspectors-container">
                                    <div class="filter-item">
                                        <input type="checkbox" id="insp-1">
                                        <label for="insp-1">Загрузка...</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="nav-pane" id="nav-objects">
                    <div class="ios-section">
                        <div class="ios-group">
                            <div class="accordion">
                                <div class="accordion-header" data-action="toggle-accordion">
                                    <div class="accordion-title" style="display:flex; align-items:center; gap:8px;">
                                        <span>🔥</span>
                                        <span>В работе</span>
                                    </div>
                                    <div class="accordion-meta">
                                        <label class="objects-active-toggle" data-stop-propagation="true">
                                            <input type="checkbox" id="filterOnlyActiveObjects" data-change-action="toggle-only-active-mode">
                                            <span>Только в работе</span>
                                        </label>
                                        <span class="inspector-counter" id="activeObjectsBadge">0</span>
                                        <span class="accordion-arrow">▼</span>
                                    </div>
                                </div>
                                <div class="accordion-content objects-list" id="objectsActiveList"></div>
                            </div>

                            <div class="accordion">
                                <div class="accordion-header" data-action="toggle-accordion">
                                    <div class="accordion-title" style="display:flex; align-items:center; gap:8px;">
                                        <span>🆕</span>
                                        <span>Новые</span>
                                    </div>
                                    <div class="accordion-meta">
                                        <span class="inspector-counter" id="newObjectsBadge">0</span>
                                        <span class="accordion-arrow">▼</span>
                                    </div>
                                </div>
                                <div class="accordion-content objects-list" id="objectsNewList"></div>
                            </div>

                            <div class="accordion">
                                <div class="accordion-header" data-action="toggle-accordion">
                                    <div class="accordion-title" style="display:flex; align-items:center; gap:8px;">
                                        <span>✅</span>
                                        <span>Выполнены</span>
                                    </div>
                                    <div class="accordion-meta">
                                        <label class="objects-active-toggle" data-stop-propagation="true">
                                            <input type="checkbox" id="showCompletedOnMap" data-change-action="toggle-show-completed-on-map">
                                            <span>Показать</span>
                                        </label>
                                        <span class="inspector-counter" id="completedObjectsBadge">0</span>
                                        <span class="accordion-arrow">▼</span>
                                    </div>
                                </div>
                                <div class="accordion-content objects-list" id="objectsCompletedList"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Menu -->
            <div class="modern-menu-container">
                <div class="modern-search-wrapper" id="objectsSearchWrapper">
                    <div class="modern-search-box">
                        <div class="modern-search-icon" aria-hidden="true">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                            </svg>
                        </div>
                        <input
                            type="text"
                            id="objectsSearchInput"
                            class="modern-search-input"
                            placeholder="Найти адрес, номер точки..."
                            data-input-action="objects-search"
                        >
                    </div>
                </div>
                <div class="modern-menu" id="modernMenu">
                    <div class="menu-indicator" id="menuIndicator">
                        <div class="menu-indicator-inner" id="menuIndicatorInner">
                            <div class="lens-btn">
                                <svg viewBox="0 0 24 24"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
                                <span class="modern-menu-label">Списки</span>
                            </div>
                            <div class="lens-btn">
                                <svg viewBox="0 0 24 24"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"/></svg>
                                <span class="modern-menu-label">Объекты</span>
                            </div>
                            <div class="lens-btn">
                                <svg viewBox="0 0 24 24"><path d="M20.5 3l-5.5 2-6-2-5.5 2v16l5.5-2 6 2 5.5-2V3zm-11 2.18l6 2.04v11.6l-6-2.04V5.18zM5 6.82l3.5-1.27v11.6L5 18.42V6.82zM19 18.42l-3.5 1.27V8.09L19 6.82v11.6z"/></svg>
                                <span class="modern-menu-label">Карта</span>
                            </div>
                            <div class="lens-btn" style="color: #e74c3c;">
                                <svg viewBox="0 0 24 24"><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg>
                                <span class="modern-menu-label">Выход</span>
                            </div>
                        </div>
                    </div>
                    
                    <button class="modern-menu-btn active" data-action="switch-nav" data-tab="lists" id="btn-lists">
                        <svg viewBox="0 0 24 24"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
                        <span class="modern-menu-label">Списки</span>
                    </button>
                    <button class="modern-menu-btn" data-action="switch-nav" data-tab="objects" id="btn-objects">
                        <svg viewBox="0 0 24 24"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"/></svg>
                        <span class="modern-menu-label">Объекты</span>
                    </button>
                    <button class="modern-menu-btn" data-action="switch-nav" data-tab="map" id="btn-map">
                        <svg viewBox="0 0 24 24"><path d="M20.5 3l-5.5 2-6-2-5.5 2v16l5.5-2 6 2 5.5-2V3zm-11 2.18l6 2.04v11.6l-6-2.04V5.18zM5 6.82l3.5-1.27v11.6L5 18.42V6.82zM19 18.42l-3.5 1.27V8.09L19 6.82v11.6z"/></svg>
                        <span class="modern-menu-label">Карта</span>
                    </button>
                    <button class="modern-menu-btn" data-action="switch-nav" data-tab="exit" id="btn-exit" style="color: #e74c3c;">
                        <svg viewBox="0 0 24 24"><path d="M16 17v-3H9v-4h7V7l5 5-5 5M14 2a2 2 0 012 2v2h-2V4H5v16h9v-2h2v2a2 2 0 01-2 2H5a2 2 0 01-2-2V4a2 2 0 012-2h9z"/></svg>
                        <span class="modern-menu-label">Выход</span>
                    </button>
                </div>
            </div>
        </aside>
        
        <!-- Карта -->
        <div class="map-container">
            <div id="map"></div>
        </div>
        
        <!-- Боковая панель управления инспекторами -->
        <div id="inspectorManagementPanel" class="side-panel hidden">
            <div class="side-panel-header">
                <h3>🧭 Кастомизация и управление инспекторами</h3>
                <button class="close-btn" data-action="close-inspector-management">×</button>
            </div>
            <div class="side-panel-search">
                <input type="text" id="searchManagement" placeholder="🔍 Поиск по инспекторам..." data-input-action="filter-management-inspectors">
            </div>
            <div class="side-panel-body" id="inspectorManagementBody">
                <div class="loading">Загрузка...</div>
            </div>
        </div>
    </div>

    <div class="mobile-sidebar-backdrop" id="mobileSidebarBackdrop"></div>
    <div class="mobile-fab-menu" id="mobileFabMenu">
        <div class="map-inline-search" id="mapInlineSearch">
            <div class="map-inline-search__box">
                <input
                    id="mapInlineSearchInput"
                    class="map-inline-search__input"
                    type="text"
                    placeholder="Найти на карте: адрес, номер точки..."
                    autocomplete="off"
                    data-input-action="map-inline-search-input"
                >
                <button class="map-inline-search__btn map-inline-search__btn--close" type="button" data-action="map-inline-search-close" aria-label="Скрыть поиск">
                    <span class="map-inline-search__close-arrow" aria-hidden="true">&rarr;</span>
                </button>
            </div>
        </div>
        <button class="mobile-fab-action mobile-fab-action--menu" type="button" data-action="mobile-fab-open-menu" aria-label="Открыть меню">
            <svg viewBox="0 0 24 24"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
        </button>
        <button class="mobile-fab-action mobile-fab-action--search" type="button" data-action="mobile-fab-search" aria-label="Открыть поиск">
            <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.47 6.47 0 0 0 4.23-1.57l.27.28v.79L20 21.5 21.5 20l-6-6zM9.5 14A4.5 4.5 0 1 1 14 9.5 4.5 4.5 0 0 1 9.5 14z"/></svg>
        </button>
        <button class="mobile-hamburger" id="mobileSidebarToggle" type="button" data-action="toggle-mobile-fab" aria-label="Открыть мобильные действия" aria-expanded="false">
            <span class="mobile-hamburger__bars"></span>
        </button>
    </div>

    <script>
        /**
         * ============================================
         * M-PRO: модульная архитектура приложения
         * ============================================
         *
         * Структура модулей:
         * 1. CONFIG    - константы и конфигурация
         * 2. STATE     - управление состоянием приложения
         * 3. UTILS     - вспомогательные функции
         * 4. API       - взаимодействие с внешними API (GAS, Яндекс)
         * 5. UI        - рендеринг интерфейса
         * 6. MAP       - карта и управление объектами
         * 7. AUTH      - авторизация
         * 8. INIT      - инициализация приложения
         * ============================================
         */

        // ============================================
        // Модуль конфигурации
        // ============================================
        
        const CONFIG = Object.freeze({
            // Конфигурация Firebase
            FIREBASE: {
                apiKey: "AIzaSyASjRfL1IuhfI8yxjx3eep7RJyzFO2D62U",
                authDomain: "m-pro-sync.firebaseapp.com",
                databaseURL: "https://m-pro-sync-default-rtdb.europe-west1.firebasedatabase.app",
                projectId: "m-pro-sync",
                storageBucket: "m-pro-sync.firebasestorage.app",
                messagingSenderId: "504908226667",
                appId: "1:504908226667:web:ea5dcb9acfd7d6a460912e"
            },
            SYNC: {
                PATH: 'sync/lastUpdate',
                RELOAD_DEBOUNCE_MS: 700,
                IGNORE_OWN_EVENT_MS: 2000
            },
            
            // Адрес Google Apps Script
            SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbyAroqG8zPf64EEoteWrNkh7y8QjdOXvYBzWfLcMsuH4btjCIPMAl_dNXHNBsSzSkdc/exec',
            
            // Конфигурация Яндекс.Диска
            YANDEX: {
                ROOT_PATH: 'Осмотры объектов АНО СМГ',
                SUBFOLDERS: Object.freeze([
                    'Акт + селфи + СКУД + ОЖР',
                    'Общий фотоотчет',
                    'Периметральное ограждение + Подъездные пути',
                    'Замечания строительной площадки + Грунт'
                ])
            },
            
            // Конфигурация карты
            MAP: {
                DEFAULT_CENTER: [55.7558, 37.6176],
                DEFAULT_ZOOM: 10,
                // Константы расчета смещения (спираль Архимеда)
                SPIRAL: {
                    ANGLE_STEP: 1.2,      // радианы
                    RADIUS_BASE: 0.001,   // градусы (~100-300 метров)
                    RADIUS_MULTIPLIER: Math.sqrt
                },
                // Размеры иконок в пикселях
                ICON_SIZE: {
                    DEFAULT: [30, 30],
                    ACTIVE: [50, 50]
                }
            },
            
            // Типы статусов объекта
            STATUS: Object.freeze({
                NEW: 'new',
                ACTIVE: 'active',
                COMPLETED: 'completed',
                DENIED: 'denied'
            }),
            
            // Соответствие источников отображаемым названиям
            SOURCES: Object.freeze({
                Map: 'ГС',
                Laboratory: 'Лаборатория',
                ConstructionControl: 'СК',
                DMS: 'ДМС'
            }),
            
            // Ключ временной сессии (до закрытия вкладки)
            SESSION_KEY: 'mpro_user',

            // Ключ постоянной сессии (режим "Запомнить вход")
            SESSION_PERSIST_KEY: 'mpro_user_persist',

            // Сохраненный пароль для поля авторизации (когда включен "Запомнить вход")
            AUTH_PASSWORD_KEY: 'mpro_auth_password',

            // Сохраненное состояние чекбокса "Запомнить вход"
            AUTH_REMEMBER_KEY: 'mpro_auth_remember',

            // Ключ в localStorage для выбранных фильтров
            FILTERS_STORAGE_KEY: 'mpro_filters',

            // Маркер для WorkDay, когда геолокация недоступна
            WORKDAY_NO_GEO_MARKER: 'ГЕОЛОКАЦИЯ НЕДОСТУПНА: запросить селфи',
            
            // Таймаут запроса в миллисекундах
            TIMEOUT: 15000,
            
            // Длительности UI-анимаций (мс)
            ANIMATION: {
                MENU_TRANSITION: 250,
                NOTIFICATION_DURATION: 4000,
                BUTTON_RESET_DELAY: 1500,
                PANEL_TRANSITION: 300,
                MODAL_ANIMATION: 250
            },
            
            // Настройки индикатора прогресса
            PROGRESS: {
                INITIAL_PERCENT: 20,
                COMPLETE_PERCENT: 100
            },
            
            // Форматирование даты
            DATE: {
                LOCALE: 'ru-RU',
                FORMAT: {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                }
            },
            
            // Значения по умолчанию
            DEFAULTS: {
                INSPECTOR_ICON: '👤',
                INSPECTOR_COLOR: '#1f6fb2',
                INSPECTOR_STATUS: 'active',
                MAP_PRESET: 'islands#dotIcon',
                UNKNOWN_INSPECTOR: 'Не назначен'
            },
            
            // Слои по z-индексу
            Z_INDEX: {
                ACTIVE_OBJECTS: 1000,
                NOTIFICATION: 999999,
                AUTH_OVERLAY: 99999,
                SIDE_PANEL: 10000,
                MODAL: 1500
            }
        });

        const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === '1';
        function debugLog(...args) {
            if (!DEBUG_MODE) return;
            console.log(...args);
        }
        // ============================================
        // Глобальное состояние приложения
        // ============================================

        const AppState = {
            ui: {
                showInspectorsHomes: false,
                currentOpenObjectId: null,
                delegatedEventsInitialized: false,
                objectsListUpdateTimer: null,
                objectsListRenderQueued: false,
                mapRenderQueued: false,
                domByIdCache: {},
                filterCheckboxesCache: {
                    inspectors: [],
                    lists: []
                },
                objectsListRenderCache: {
                    active: '',
                    new: '',
                    completed: ''
                },
                objectsBadgesCache: {
                    active: null,
                    new: null,
                    completed: null
                }
            },
            filters: {
                currentFilters: {
                    inspectors: [],
                    lists: []
                },
                objectsTabInspectorFiltersCache: { inspectors: [], divisions: [] },
                showOnlyActiveObjects: false,
                showCompletedOnMap: false,
                recentlyCompletedUntil: new Map()
            },
            data: {
                inspectorsHomesData: {},
                inspectorsConfig: {},
                objectsData: [],
                objectsById: new Map(),
                inspectorsList: [],
                inspectorsWorkDay: {},
                inspectorMessages: {
                    individual: [],
                    group: []
                }
            },
            map: {
                mapInstance: null,
                inspectorsHomesLayer: null,
                objectManager: null,
                activeObjectsLayer: null,
                coordinateCounter: 0,
                lastMapRenderSignature: ''
            },
            runtime: {
                currentUser: null,
                sessionToken: '',
                dataLoadPromise: null,
                mapSearchQuery: '',
                workDay: {
                    isLoaded: false,
                    isOpen: false,
                    isSyncing: false,
                    openTime: null,
                    lastError: '',
                    lastSyncAt: 0,
                    lastSyncInspectorNorm: ''
                }
            }
        };

        const FiltersState = Object.freeze({
            getCurrent() {
                return AppState.filters.currentFilters;
            },
            setCurrent(nextFilters) {
                const inspectors = Array.isArray(nextFilters?.inspectors) ? nextFilters.inspectors.slice() : [];
                const lists = Array.isArray(nextFilters?.lists)
                    ? nextFilters.lists
                        .filter(item => item && typeof item === 'object')
                        .map(item => ({ name: item.name, division: item.division }))
                    : [];
                AppState.filters.currentFilters = { inspectors, lists };
            },
            getObjectsTabInspectorCache() {
                return AppState.filters.objectsTabInspectorFiltersCache;
            },
            setObjectsTabInspectorCache(nextCache) {
                AppState.filters.objectsTabInspectorFiltersCache = {
                    inspectors: Array.isArray(nextCache?.inspectors) ? nextCache.inspectors.slice() : [],
                    divisions: Array.isArray(nextCache?.divisions) ? nextCache.divisions.slice() : []
                };
            },
            isOnlyActiveMode() {
                return !!AppState.filters.showOnlyActiveObjects;
            },
            setOnlyActiveMode(value) {
                AppState.filters.showOnlyActiveObjects = !!value;
            },
            isShowCompletedOnMap() {
                return !!AppState.filters.showCompletedOnMap;
            },
            setShowCompletedOnMap(value) {
                AppState.filters.showCompletedOnMap = !!value;
            },
            getRecentlyCompletedMap() {
                return AppState.filters.recentlyCompletedUntil;
            },
            setRecentlyCompletedUntil(objectId, untilTs) {
                AppState.filters.recentlyCompletedUntil.set(String(objectId), untilTs);
            },
            clearRecentlyCompleted(objectId) {
                AppState.filters.recentlyCompletedUntil.delete(String(objectId));
            }
        });

        const UIState = Object.freeze({
            isDelegatedEventsInitialized() {
                return !!AppState.ui.delegatedEventsInitialized;
            },
            markDelegatedEventsInitialized() {
                AppState.ui.delegatedEventsInitialized = true;
            },
            toggleInspectorsHomesVisible() {
                AppState.ui.showInspectorsHomes = !AppState.ui.showInspectorsHomes;
                return AppState.ui.showInspectorsHomes;
            },
            isInspectorsHomesVisible() {
                return !!AppState.ui.showInspectorsHomes;
            },
            getObjectsListUpdateTimer() {
                return AppState.ui.objectsListUpdateTimer;
            },
            setObjectsListUpdateTimer(timerId) {
                AppState.ui.objectsListUpdateTimer = timerId ?? null;
            },
            getDomById(id) {
                const key = String(id || '');
                if (!key) return null;
                const cached = AppState.ui.domByIdCache[key];
                if (cached && cached.isConnected) return cached;
                const node = document.getElementById(key);
                if (node) AppState.ui.domByIdCache[key] = node;
                return node || null;
            },
            setFilterCheckboxes(type, checkboxes) {
                const key = type === 'lists' ? 'lists' : 'inspectors';
                AppState.ui.filterCheckboxesCache[key] = Array.isArray(checkboxes)
                    ? checkboxes.filter(cb => cb && cb.isConnected)
                    : [];
            },
            getFilterCheckboxes(type) {
                const key = type === 'lists' ? 'lists' : 'inspectors';
                const current = Array.isArray(AppState.ui.filterCheckboxesCache[key])
                    ? AppState.ui.filterCheckboxesCache[key]
                    : [];
                const alive = current.filter(cb => cb && cb.isConnected);
                if (alive.length !== current.length) {
                    AppState.ui.filterCheckboxesCache[key] = alive;
                }
                return alive;
            },
            isObjectsListRenderQueued() {
                return !!AppState.ui.objectsListRenderQueued;
            },
            setObjectsListRenderQueued(value) {
                AppState.ui.objectsListRenderQueued = !!value;
            },
            isMapRenderQueued() {
                return !!AppState.ui.mapRenderQueued;
            },
            setMapRenderQueued(value) {
                AppState.ui.mapRenderQueued = !!value;
            },
            getObjectsBadge(sectionKey) {
                return AppState.ui.objectsBadgesCache[sectionKey];
            },
            setObjectsBadge(sectionKey, count) {
                AppState.ui.objectsBadgesCache[sectionKey] = count;
            },
            getObjectsListRenderSignature(sectionKey) {
                return AppState.ui.objectsListRenderCache[sectionKey];
            },
            setObjectsListRenderSignature(sectionKey, signature) {
                AppState.ui.objectsListRenderCache[sectionKey] = signature;
            },
            snapshotObjectsListRenderCache() {
                return { ...AppState.ui.objectsListRenderCache };
            },
            restoreObjectsListRenderCache(snapshot) {
                AppState.ui.objectsListRenderCache = {
                    active: snapshot?.active ?? '',
                    new: snapshot?.new ?? '',
                    completed: snapshot?.completed ?? ''
                };
            },
            getCurrentOpenObjectId() {
                return AppState.ui.currentOpenObjectId;
            },
            setCurrentOpenObjectId(objectId) {
                AppState.ui.currentOpenObjectId = objectId;
            },
            clearCurrentOpenObjectId() {
                AppState.ui.currentOpenObjectId = null;
            }
        });

        const DataState = Object.freeze({
            getInspectorsHomesData() {
                return AppState.data.inspectorsHomesData;
            },
            setInspectorsHomesData(homesData) {
                AppState.data.inspectorsHomesData = (homesData && typeof homesData === 'object') ? homesData : {};
            },
            clearInspectorsHomesData() {
                AppState.data.inspectorsHomesData = {};
            },
            getInspectorsConfig() {
                return AppState.data.inspectorsConfig;
            },
            setInspectorsConfig(config) {
                if (!config || typeof config !== 'object') {
                    AppState.data.inspectorsConfig = {};
                    return;
                }
                const next = {};
                Object.keys(config).forEach(name => {
                    const raw = (config[name] && typeof config[name] === 'object') ? config[name] : {};
                    next[name] = {
                        ...raw,
                        status: normalizeInspectorManagementStatus_(raw.status)
                    };
                });
                AppState.data.inspectorsConfig = next;
            },
            ensureInspectorConfig(inspectorName) {
                const config = this.getInspectorsConfig();
                if (!config[inspectorName]) config[inspectorName] = {};
                return config[inspectorName];
            },
            getInspectorsList() {
                return AppState.data.inspectorsList;
            },
            setInspectorsList(inspectorsList) {
                AppState.data.inspectorsList = Array.isArray(inspectorsList) ? inspectorsList : [];
            },
            getInspectorsWorkDay() {
                return (AppState.data.inspectorsWorkDay && typeof AppState.data.inspectorsWorkDay === 'object')
                    ? AppState.data.inspectorsWorkDay
                    : {};
            },
            setInspectorsWorkDay(payload) {
                AppState.data.inspectorsWorkDay = (payload && typeof payload === 'object') ? payload : {};
            },
            clearInspectorsWorkDay() {
                AppState.data.inspectorsWorkDay = {};
            },
            getObjectsData() {
                return AppState.data.objectsData;
            },
            setObjectsData(objectsData) {
                const nextObjects = Array.isArray(objectsData) ? objectsData : [];
                const byId = new Map();
                for (let i = 0; i < nextObjects.length; i += 1) {
                    const obj = nextObjects[i];
                    const idKey = String(obj?.id ?? '');
                    if (!idKey) continue;
                    const division = resolveObjectDivision_(obj);
                    const listValue = String(obj?.list || '');
                    obj.__divisionResolved = division;
                    obj.__listDivisionKey = `${division}::${listValue}`;
                    obj.__searchBlobLower = `${idKey}|${listValue}|${String(obj?.address || '')}`.toLowerCase();
                    if (!byId.has(idKey)) byId.set(idKey, obj);
                }
                AppState.data.objectsData = nextObjects;
                AppState.data.objectsById = byId;
            },
            findObjectById(objectId) {
                const idKey = String(objectId ?? '');
                if (idKey && AppState.data.objectsById.has(idKey)) {
                    return AppState.data.objectsById.get(idKey) || null;
                }
                return AppState.data.objectsData.find(obj => obj.id == objectId) || null;
            },
            snapshotObjectsData() {
                return AppState.data.objectsData;
            },
            restoreObjectsData(snapshot) {
                this.setObjectsData(snapshot);
            },
            getInspectorMessages() {
                const payload = AppState.data.inspectorMessages;
                return {
                    individual: Array.isArray(payload?.individual) ? payload.individual : [],
                    group: Array.isArray(payload?.group) ? payload.group : []
                };
            },
            setInspectorMessages(messages) {
                const incoming = messages && typeof messages === 'object' ? messages : {};
                AppState.data.inspectorMessages = {
                    individual: Array.isArray(incoming.individual) ? incoming.individual : [],
                    group: Array.isArray(incoming.group) ? incoming.group : []
                };
            },
            clearInspectorMessages() {
                AppState.data.inspectorMessages = { individual: [], group: [] };
            }
        });

        const RuntimeState = Object.freeze({
            getCurrentUser() {
                return AppState.runtime.currentUser;
            },
            setCurrentUser(user) {
                AppState.runtime.currentUser = (user && typeof user === 'object') ? user : null;
            },
            clearCurrentUser() {
                AppState.runtime.currentUser = null;
            },
            hasCurrentUser() {
                return !!AppState.runtime.currentUser;
            },
            getCurrentUserName(fallback = 'Инспектор') {
                const name = AppState.runtime.currentUser?.name;
                return name ? String(name) : fallback;
            },
            getSessionToken() {
                return String(AppState.runtime.sessionToken || '');
            },
            setSessionToken(token) {
                AppState.runtime.sessionToken = String(token || '').trim();
            },
            clearSessionToken() {
                AppState.runtime.sessionToken = '';
            },
            getDataLoadPromise() {
                return AppState.runtime.dataLoadPromise;
            },
            setDataLoadPromise(promise) {
                AppState.runtime.dataLoadPromise = promise || null;
            },
            clearDataLoadPromise() {
                AppState.runtime.dataLoadPromise = null;
            },
            getMapSearchQuery() {
                return String(AppState.runtime.mapSearchQuery || '');
            },
            setMapSearchQuery(query) {
                AppState.runtime.mapSearchQuery = String(query || '');
            },
            clearMapSearchQuery() {
                AppState.runtime.mapSearchQuery = '';
            }
        });

        const WorkDayRuntimeState = Object.freeze({
            reset() {
                AppState.runtime.workDay = {
                    isLoaded: false,
                    isOpen: false,
                    isSyncing: false,
                    openTime: null,
                    lastError: '',
                    lastSyncAt: 0,
                    lastSyncInspectorNorm: ''
                };
            },
            isLoaded() {
                return !!AppState.runtime.workDay.isLoaded;
            },
            setLoaded(value) {
                AppState.runtime.workDay.isLoaded = !!value;
            },
            isOpen() {
                return !!AppState.runtime.workDay.isOpen;
            },
            setOpen(value) {
                AppState.runtime.workDay.isOpen = !!value;
            },
            isSyncing() {
                return !!AppState.runtime.workDay.isSyncing;
            },
            setSyncing(value) {
                AppState.runtime.workDay.isSyncing = !!value;
            },
            getOpenTime() {
                return AppState.runtime.workDay.openTime || null;
            },
            setOpenTime(value) {
                const raw = String(value || '').trim();
                AppState.runtime.workDay.openTime = raw || null;
            },
            getLastError() {
                return String(AppState.runtime.workDay.lastError || '');
            },
            setLastError(message) {
                AppState.runtime.workDay.lastError = String(message || '').trim();
            },
            clearError() {
                AppState.runtime.workDay.lastError = '';
            },
            markSynced(inspectorNorm) {
                AppState.runtime.workDay.lastSyncAt = Date.now();
                AppState.runtime.workDay.lastSyncInspectorNorm = String(inspectorNorm || '');
            },
            getLastSyncAt() {
                return Number(AppState.runtime.workDay.lastSyncAt || 0);
            },
            getLastSyncInspectorNorm() {
                return String(AppState.runtime.workDay.lastSyncInspectorNorm || '');
            }
        });

        const MapState = Object.freeze({
            getMapInstance() {
                return AppState.map.mapInstance;
            },
            setMapInstance(instance) {
                AppState.map.mapInstance = instance || null;
            },
            destroyMapInstance() {
                const mapInstance = AppState.map.mapInstance;
                if (mapInstance && typeof mapInstance.destroy === 'function') {
                    mapInstance.destroy();
                }
                AppState.map.mapInstance = null;
            },
            getHomesLayer() {
                return AppState.map.inspectorsHomesLayer;
            },
            setHomesLayer(layer) {
                AppState.map.inspectorsHomesLayer = layer || null;
            },
            getObjectManager() {
                return AppState.map.objectManager;
            },
            setObjectManager(manager) {
                AppState.map.objectManager = manager || null;
            },
            getActiveObjectsLayer() {
                return AppState.map.activeObjectsLayer;
            },
            setActiveObjectsLayer(layer) {
                AppState.map.activeObjectsLayer = layer || null;
            },
            areObjectLayersReady() {
                return !!(AppState.map.objectManager && AppState.map.activeObjectsLayer);
            },
            clearObjectLayers() {
                if (AppState.map.objectManager) AppState.map.objectManager.removeAll();
                if (AppState.map.activeObjectsLayer) AppState.map.activeObjectsLayer.removeAll();
            },
            resetCoordinateCounter() {
                AppState.map.coordinateCounter = 0;
            },
            getLastRenderSignature() {
                return AppState.map.lastMapRenderSignature;
            },
            setLastRenderSignature(signature) {
                AppState.map.lastMapRenderSignature = String(signature || '');
            },
            snapshotObjectLayers() {
                return {
                    objectManager: AppState.map.objectManager,
                    activeObjectsLayer: AppState.map.activeObjectsLayer
                };
            },
            restoreObjectLayers(snapshot) {
                AppState.map.objectManager = snapshot?.objectManager || null;
                AppState.map.activeObjectsLayer = snapshot?.activeObjectsLayer || null;
            }
        });
        
        // ============================================
        // ИНИЦИАЛИЗАЦИЯ
        // ============================================
        
        // Проверка авторизации до DOMContentLoaded, чтобы избежать мерцания
        function parseSessionPayload_(raw) {
            if (!raw) return null;
            try {
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return null;
                if (!parsed.user || !parsed.sessionToken) return null;
                if (parsed.expiresAt) {
                    const expiresAtMs = Date.parse(parsed.expiresAt);
                    if (Number.isFinite(expiresAtMs) && Date.now() >= expiresAtMs) return null;
                }
                return {
                    user: parsed.user,
                    sessionToken: String(parsed.sessionToken || ''),
                    expiresAt: String(parsed.expiresAt || '')
                };
            } catch (error) {
                return null;
            }
        }

        function readStoredSession_() {
            const tempRaw = sessionStorage.getItem(CONFIG.SESSION_KEY);
            const tempSession = parseSessionPayload_(tempRaw);
            if (tempSession) return tempSession;

            const persistedRaw = localStorage.getItem(CONFIG.SESSION_PERSIST_KEY);
            const persistedSession = parseSessionPayload_(persistedRaw);
            if (persistedSession) return persistedSession;

            if (persistedRaw) localStorage.removeItem(CONFIG.SESSION_PERSIST_KEY);
            return null;
        }

        function persistSession_(sessionPayload, options = {}) {
            if (!sessionPayload || !sessionPayload.user || !sessionPayload.sessionToken) return;
            const remember = !!options.remember;
            const payload = JSON.stringify({
                user: sessionPayload.user,
                sessionToken: String(sessionPayload.sessionToken || ''),
                expiresAt: String(sessionPayload.expiresAt || '')
            });
            if (remember) {
                localStorage.setItem(CONFIG.SESSION_PERSIST_KEY, payload);
                sessionStorage.removeItem(CONFIG.SESSION_KEY);
            } else {
                sessionStorage.setItem(CONFIG.SESSION_KEY, payload);
                localStorage.removeItem(CONFIG.SESSION_PERSIST_KEY);
            }
        }

        function clearStoredSession_() {
            sessionStorage.removeItem(CONFIG.SESSION_KEY);
            localStorage.removeItem(CONFIG.SESSION_PERSIST_KEY);
        }

        function readRememberedAuth_() {
            try {
                const rememberRaw = localStorage.getItem(CONFIG.AUTH_REMEMBER_KEY);
                const remember = rememberRaw === null ? true : rememberRaw === '1';
                const password = remember
                    ? String(localStorage.getItem(CONFIG.AUTH_PASSWORD_KEY) || '')
                    : '';
                return { remember, password };
            } catch (error) {
                return { remember: true, password: '' };
            }
        }

        function persistRememberedAuth_(password, remember) {
            const rememberFlag = !!remember;
            try {
                localStorage.setItem(CONFIG.AUTH_REMEMBER_KEY, rememberFlag ? '1' : '0');
                if (!rememberFlag) {
                    localStorage.removeItem(CONFIG.AUTH_PASSWORD_KEY);
                    return;
                }
                localStorage.setItem(CONFIG.AUTH_PASSWORD_KEY, String(password || ''));
            } catch (error) {
                // no-op
            }
        }

        function applyRememberedAuthToForm_() {
            const passwordInput = document.getElementById('authPassword');
            const rememberInput = document.getElementById('authRemember');
            if (!passwordInput || !rememberInput) return;

            const remembered = readRememberedAuth_();
            rememberInput.checked = !!remembered.remember;
            passwordInput.value = remembered.password || '';
        }

        const bootSession = readStoredSession_();
        const isLoggedIn = !!bootSession;
        const INSPECTOR_BLOCKED_CLICK_ACTIONS = new Set([
            'show-homes',
            'show-inspector-management',
            'archive-completed',
            'close-inspector-management',
            'toggle-inspector-card',
            'toggle-picker',
            'select-color',
            'select-icon',
            'select-status-option',
            'apply-inspector-changes',
            'cancel-entry'
        ]);
        const INSPECTOR_BLOCKED_INPUT_ACTIONS = new Set([
            'filter-management-inspectors',
            'reassign-inspector'
        ]);

        function getCurrentUserRoleNorm_() {
            return String(RuntimeState.getCurrentUser()?.role || '')
                .replace(/\u00A0/g, ' ')
                .replace(/\s+/g, ' ')
                .replace(/[\u0451\u0401]/g, '\u0435')
                .trim()
                .toLowerCase();
        }

        function isInspectorRole_() {
            const role = getCurrentUserRoleNorm_();
            return role.indexOf('\u0438\u043d\u0441\u043f\u0435\u043a\u0442') !== -1 || role.indexOf('inspector') !== -1;
        }

        function isActionAllowedForCurrentRole_(action, channel = 'click') {
            if (!action) return false;
            if (!isInspectorRole_()) return true;
            if (channel === 'input') return !INSPECTOR_BLOCKED_INPUT_ACTIONS.has(action);
            return !INSPECTOR_BLOCKED_CLICK_ACTIONS.has(action);
        }

        function applyRoleVisibility_() {
            const hideAdmin = isInspectorRole_();
            const adminSection = UIState.getDomById('adminFunctionsSection');
            const managementPanel = UIState.getDomById('inspectorManagementPanel');
            const workDaySection = UIState.getDomById('workDaySection');
            const inspectorMessagesSection = UIState.getDomById('inspectorMessagesSection');
            if (adminSection) adminSection.style.display = hideAdmin ? 'none' : '';
            if (managementPanel && hideAdmin) managementPanel.classList.add('hidden');
            if (workDaySection) workDaySection.style.display = hideAdmin ? '' : 'none';
            if (inspectorMessagesSection) inspectorMessagesSection.style.display = hideAdmin ? '' : 'none';
            renderInspectorMessages_();
        }

        function getRoleScopedObjects_(objectsData) {
            const source = Array.isArray(objectsData) ? objectsData : [];
            if (!isInspectorRole_()) return source;
            const myInspectorNorm = normalizeInspectorName_(RuntimeState.getCurrentUserName(''));
            if (!myInspectorNorm) return [];
            return source.filter(obj => normalizeInspectorName_(obj?.inspector) === myInspectorNorm);
        }

        function getRoleScopedInspectors_(inspectorsList) {
            const source = Array.isArray(inspectorsList) ? inspectorsList : [];
            if (!isInspectorRole_()) return source;
            const myInspectorNorm = normalizeInspectorName_(RuntimeState.getCurrentUserName(''));
            if (!myInspectorNorm) return [];
            return source.filter(insp => normalizeInspectorName_(insp?.name) === myInspectorNorm);
        }

        function initDelegatedEvents_() {
            if (UIState.isDelegatedEventsInitialized()) return;
            UIState.markDelegatedEventsInitialized();

            document.addEventListener('click', (event) => {
                if (!(event.target instanceof Element)) return;

                const stopPropagationNode = event.target.closest('[data-stop-propagation="true"]');
                if (stopPropagationNode) {
                    event.stopPropagation();
                    return;
                }

                const fabMenu = document.getElementById('mobileFabMenu');
                if (fabMenu && (isMobileFabExpanded_() || isMapInlineSearchOpen_()) && !event.target.closest('#mobileFabMenu')) {
                    setMobileFabExpanded_(false);
                    setMapInlineSearchOpen_(false);
                }

                const actionNode = event.target.closest('[data-action]');
                if (!actionNode) return;

                const action = actionNode.dataset.action;
                if (!isActionAllowedForCurrentRole_(action, 'click')) return;
                switch (action) {
                    case 'close-object-details':
                        closeObjectDetails();
                        break;
                    case 'login':
                        doLogin();
                        break;
                    case 'show-homes':
                        AppModules.Map.showHomes();
                        break;
                    case 'show-inspector-management':
                        AppModules.Customization.showInspectorManagement();
                        break;
                    case 'archive-completed':
                        archiveCompletedObjects();
                        break;
                    case 'toggle-filter':
                        if (actionNode.dataset.filterId) {
                            toggleFilter(actionNode.dataset.filterId);
                        }
                        break;
                    case 'toggle-accordion':
                        toggleAccordion(actionNode);
                        break;
                    case 'switch-nav':
                        if (actionNode.dataset.tab) {
                            AppModules.Objects.switchNav(actionNode.dataset.tab);
                        }
                        break;
                    case 'toggle-mobile-fab':
                        toggleMobileFabMenu_();
                        break;
                    case 'mobile-fab-open-menu':
                        openMobileSidebarFromFab_('lists');
                        break;
                    case 'mobile-fab-search':
                        toggleMapInlineSearch_();
                        break;
                    case 'map-inline-search-submit':
                        submitMapInlineSearch_();
                        break;
                    case 'map-inline-search-close':
                        setMapInlineSearchOpen_(false);
                        setMobileFabExpanded_(true);
                        break;
                    case 'close-inspector-management':
                        AppModules.Customization.closeInspectorManagement();
                        break;
                    case 'toggle-inspector-card': {
                        const card = actionNode.closest('.inspector-card');
                        if (card) AppModules.Customization.toggleInspectorCard(card);
                        break;
                    }
                    case 'toggle-picker':
                        if (actionNode.dataset.pickerType && actionNode.dataset.cardId) {
                            AppModules.Customization.togglePicker(actionNode.dataset.pickerType, actionNode.dataset.cardId);
                        }
                        break;
                    case 'expand-picker-options':
                        if (actionNode.dataset.pickerType && actionNode.dataset.cardId) {
                            AppModules.Customization.expandPickerOptions(actionNode.dataset.pickerType, actionNode.dataset.cardId);
                        }
                        break;
                    case 'select-color':
                        if (actionNode.dataset.cardId && actionNode.dataset.color) {
                            AppModules.Customization.selectColor(actionNode.dataset.cardId, actionNode.dataset.color);
                        }
                        break;
                    case 'select-icon':
                        if (actionNode.dataset.cardId && actionNode.dataset.icon) {
                            AppModules.Customization.selectIcon(actionNode.dataset.cardId, actionNode.dataset.icon);
                        }
                        break;
                    case 'select-status-option':
                        if (actionNode.dataset.cardId && actionNode.dataset.status) {
                            AppModules.Customization.selectStatusOption(
                                actionNode.dataset.cardId,
                                actionNode.dataset.status,
                                actionNode.dataset.displayText || '',
                                event
                            );
                        }
                        break;
                    case 'apply-inspector-changes':
                        if (actionNode.dataset.inspector && actionNode.dataset.cardId) {
                            AppModules.Customization.applyInspectorChanges(actionNode.dataset.inspector, actionNode.dataset.cardId);
                        }
                        break;
                    case 'mark-entry':
                        if (actionNode.dataset.objectId) markEntry(actionNode.dataset.objectId);
                        break;
                    case 'mark-exit':
                        if (actionNode.dataset.objectId) markExit(actionNode.dataset.objectId);
                        break;
                    case 'cancel-entry':
                        if (actionNode.dataset.objectId) cancelEntry(actionNode.dataset.objectId);
                        break;
                    case 'mark-denied':
                        if (actionNode.dataset.objectId) markDenied(actionNode.dataset.objectId);
                        break;
                    case 'call-laboratory':
                        if (actionNode.dataset.objectId) callLaboratory(actionNode.dataset.objectId);
                        break;
                    case 'copy-coordinates':
                        if (actionNode.dataset.coordinates) copyCoordinates(actionNode.dataset.coordinates);
                        break;
                    case 'focus-object-from-list':
                        if (actionNode.dataset.objectId) focusObjectFromObjectsTabById_(actionNode.dataset.objectId);
                        break;
                    case 'yandex-disk':
                        handleYandexDiskAction_(actionNode);
                        break;
                    default:
                        break;
                }
            });

            document.addEventListener('change', (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const action = target.dataset?.changeAction;
                if (!action) return;

                switch (action) {
                    case 'toggle-workday':
                        handleWorkDayToggleChange_(target);
                        break;
                    case 'toggle-only-active-mode':
                        AppModules.Filters.toggleOnlyActiveMode(!!target.checked);
                        break;
                    case 'toggle-show-completed-on-map':
                        AppModules.Filters.toggleShowCompletedOnMap(!!target.checked);
                        break;
                    case 'update-map-filters':
                        AppModules.Filters.updateMapFilters();
                        break;
                    case 'toggle-division-filters':
                        if (target.dataset.division && target.dataset.filterType) {
                            AppModules.Filters.toggleDivisionFilters(target.dataset.division, target.dataset.filterType, !!target.checked);
                        }
                        break;
                    case 'reassign-inspector':
                        if (target.dataset.objectId) {
                            reassignInspector(target.dataset.objectId, target.value);
                        }
                        break;
                    case 'custom-inspector-color':
                        if (target.dataset.cardId && target.value) {
                            selectColor(target.dataset.cardId, target.value);
                        }
                        break;
                    default:
                        break;
                }
            });

            document.addEventListener('input', (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const action = target.dataset?.inputAction;
                if (!action) return;
                if (!isActionAllowedForCurrentRole_(action, 'input')) return;

                switch (action) {
                    case 'objects-search':
                        handleObjectsSearchInput_(target);
                        break;
                    case 'map-inline-search-input':
                        handleMapInlineSearchInput_(target);
                        break;
                    case 'filter-management-inspectors':
                        AppModules.Customization.filterManagementInspectors();
                        break;
                    default:
                        break;
                }
            });
        }

        function syncMenuIndicator_(tabName = '') {
            const menu = document.getElementById('modernMenu');
            if (!menu) return false;

            let activeBtn = null;
            if (tabName) {
                activeBtn = document.getElementById(`btn-${tabName}`);
            }
            if (!activeBtn) {
                activeBtn = menu.querySelector('.modern-menu-btn.active') || menu.querySelector('.modern-menu-btn');
            }
            if (!activeBtn) return false;

            const indicator = document.getElementById('menuIndicator');
            const indicatorInner = document.getElementById('menuIndicatorInner');
            if (indicator) {
                indicator.style.width = `${activeBtn.offsetWidth}px`;
                indicator.style.left = `${activeBtn.offsetLeft}px`;
            }
            if (indicatorInner) {
                indicatorInner.style.width = `${menu.offsetWidth}px`;
                indicatorInner.style.left = `-${activeBtn.offsetLeft}px`;
            }

            return true;
        }

        function scheduleMenuIndicatorSync_() {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    syncMenuIndicator_();
                });
            });
        }

        function isMobileViewport_() {
            return window.matchMedia('(max-width: 980px)').matches;
        }

        let lastSyncedViewportHeight_ = 0;
        let fitMapToViewportRaf_ = 0;

        function scheduleMapFitToViewport_() {
            const mapInstance = MapState.getMapInstance();
            if (!mapInstance || !mapInstance.container || typeof mapInstance.container.fitToViewport !== 'function') {
                return;
            }
            if (fitMapToViewportRaf_) {
                cancelAnimationFrame(fitMapToViewportRaf_);
            }
            fitMapToViewportRaf_ = requestAnimationFrame(() => {
                fitMapToViewportRaf_ = 0;
                try {
                    mapInstance.container.fitToViewport();
                } catch (err) {
                    // Защита от редких race-condition в iOS Safari при смене viewport.
                }
            });
        }

        function syncViewportHeight_() {
            const root = document.documentElement;
            if (!root) return;

            const vv = window.visualViewport;
            const vvHeight = vv && Number(vv.height);
            const innerHeight = Number(window.innerHeight);
            const nextHeight = Math.round((vvHeight && vvHeight > 0) ? vvHeight : innerHeight);
            if (!Number.isFinite(nextHeight) || nextHeight < 320) return;

            if (nextHeight === lastSyncedViewportHeight_) return;
            lastSyncedViewportHeight_ = nextHeight;
            root.style.setProperty('--app-height', `${nextHeight}px`);
            scheduleMapFitToViewport_();
            syncFilterPanelHeight_(document.getElementById('filter-lists'));
            syncFilterPanelHeight_(document.getElementById('filter-inspectors'));
        }

        function getMainSidebarElement_() {
            return document.getElementById('mainSidebar') || document.querySelector('.sidebar');
        }

        function getMobileFabMenuElement_() {
            return document.getElementById('mobileFabMenu');
        }

        function isMobileFabExpanded_() {
            const fabMenu = getMobileFabMenuElement_();
            return !!(fabMenu && fabMenu.classList.contains('mobile-fab-menu--expanded'));
        }

        function isMapInlineSearchOpen_() {
            const fabMenu = getMobileFabMenuElement_();
            return !!(fabMenu && fabMenu.classList.contains('mobile-fab-menu--search-open'));
        }

        function setMobileFabExpanded_(nextExpanded) {
            const fabMenu = getMobileFabMenuElement_();
            const toggle = document.getElementById('mobileSidebarToggle');
            const isMobile = isMobileViewport_();
            const sidebarOpen = document.body.classList.contains('mobile-sidebar-open');
            const shouldExpand = !!nextExpanded && isMobile && !sidebarOpen;
            const shouldActive = shouldExpand || isMapInlineSearchOpen_();

            if (fabMenu) {
                fabMenu.classList.toggle('mobile-fab-menu--expanded', shouldExpand);
            }
            if (toggle) {
                toggle.classList.toggle('active', shouldActive);
                toggle.setAttribute('aria-expanded', shouldActive ? 'true' : 'false');
                toggle.setAttribute('aria-label', shouldActive ? 'Свернуть мобильные действия' : 'Открыть мобильные действия');
            }
        }

        function toggleMobileFabMenu_() {
            if (!isMobileViewport_()) return;
            if (isMapInlineSearchOpen_()) {
                setMapInlineSearchOpen_(false);
                setMobileFabExpanded_(true);
                return;
            }
            setMobileFabExpanded_(!isMobileFabExpanded_());
        }

        function setMapInlineSearchOpen_(nextOpen) {
            const wrapper = document.getElementById('mapInlineSearch');
            const fabMenu = getMobileFabMenuElement_();
            const toggle = document.getElementById('mobileSidebarToggle');
            const input = document.getElementById('mapInlineSearchInput');
            const isMobile = isMobileViewport_();
            const sidebarOpen = document.body.classList.contains('mobile-sidebar-open');
            const shouldOpen = !!nextOpen && isMobile && !sidebarOpen;
            if (!wrapper) return;
            wrapper.classList.toggle('visible', shouldOpen);
            if (fabMenu) {
                fabMenu.classList.toggle('mobile-fab-menu--search-open', shouldOpen);
            }
            if (toggle) {
                const shouldActive = shouldOpen || isMobileFabExpanded_();
                toggle.classList.toggle('active', shouldActive);
                toggle.setAttribute('aria-expanded', shouldActive ? 'true' : 'false');
                toggle.setAttribute('aria-label', shouldActive ? 'Свернуть мобильные действия' : 'Открыть мобильные действия');
            }
            if (shouldOpen && input) {
                requestAnimationFrame(() => {
                    input.focus();
                    input.select();
                });
            } else if (input) {
                input.blur();
                if (input.value || RuntimeState.getMapSearchQuery()) {
                    setMapSearchQuery_('');
                }
            }
        }

        function toggleMapInlineSearch_() {
            const isOpen = isMapInlineSearchOpen_();
            setMobileFabExpanded_(false);
            AppModules.Objects.switchNav('map');
            setMapInlineSearchOpen_(!isOpen);
        }

        function normalizeMapSearchQuery_(rawValue) {
            return String(rawValue || '')
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
        }

        function syncSearchInputsValue_(rawValue, sourceId = '') {
            const safeRaw = String(rawValue || '');
            const objectsInput = document.getElementById('objectsSearchInput');
            const mapInput = document.getElementById('mapInlineSearchInput');

            if (objectsInput && sourceId !== 'objectsSearchInput' && objectsInput.value !== safeRaw) {
                objectsInput.value = safeRaw;
            }
            if (mapInput && sourceId !== 'mapInlineSearchInput' && mapInput.value !== safeRaw) {
                mapInput.value = safeRaw;
            }
        }

        function setMapSearchQuery_(rawValue, options = {}) {
            const sourceId = String(options.sourceId || '');
            syncSearchInputsValue_(rawValue, sourceId);

            const nextQuery = normalizeMapSearchQuery_(rawValue);
            if (RuntimeState.getMapSearchQuery() === nextQuery) {
                scheduleObjectsListUpdate_();
                return;
            }
            RuntimeState.setMapSearchQuery(nextQuery);
            scheduleMapUpdate_();
            scheduleObjectsListUpdate_();
        }

        function handleMapInlineSearchInput_(target) {
            if (!(target instanceof HTMLInputElement)) return;
            setMapSearchQuery_(target.value, { sourceId: target.id });
        }

        function handleObjectsSearchInput_(target) {
            if (!(target instanceof HTMLInputElement)) return;
            setMapSearchQuery_(target.value, { sourceId: target.id });
        }

        function submitMapInlineSearch_() {
            const input = document.getElementById('mapInlineSearchInput');
            if (!input) return;
            setMapSearchQuery_(input.value, { sourceId: input.id });
            input.blur();
        }

        function setMobileSidebarOpen_(nextOpen) {
            const sidebar = getMainSidebarElement_();
            const backdrop = document.getElementById('mobileSidebarBackdrop');
            const isMobile = isMobileViewport_();

            if (!sidebar) return;

            const shouldOpen = !!nextOpen && isMobile;
            if (shouldOpen) {
                setMobileFabExpanded_(false);
                setMapInlineSearchOpen_(false);
            }
            sidebar.classList.toggle('sidebar--mobile-open', shouldOpen);
            document.body.classList.toggle('mobile-sidebar-open', shouldOpen);

            if (backdrop) {
                backdrop.classList.toggle('visible', shouldOpen);
            }
        }

        function openMobileSidebarFromFab_(tabName = 'lists') {
            if (!isMobileViewport_()) return;
            setMobileFabExpanded_(false);
            setMobileSidebarOpen_(true);
            if (tabName) {
                switchNav(tabName);
            }
        }

        function closeMobileSidebar_() {
            setMobileSidebarOpen_(false);
        }

        function syncMobileLayoutState_() {
            if (!isMobileViewport_()) {
                setMobileSidebarOpen_(false);
                setMobileFabExpanded_(false);
                setMapInlineSearchOpen_(false);
            }
        }

        const RealtimeSyncState = {
            database: null,
            path: '',
            isListening: false,
            lastSeenTs: 0,
            lastOwnWriteTs: 0,
            refreshTimer: null,
            refreshInFlight: false,
            refreshQueued: false
        };

        function initRealtimeSync_() {
            if (RealtimeSyncState.isListening) return;
            if (!window.firebase || typeof firebase.database !== 'function') return;

            try {
                RealtimeSyncState.database = firebase.database();
            } catch (error) {
                console.warn('Realtime sync init failed:', error);
                return;
            }

            const syncPath = String(CONFIG.SYNC?.PATH || 'sync/lastUpdate').trim() || 'sync/lastUpdate';
            RealtimeSyncState.path = syncPath;

            RealtimeSyncState.database.ref(syncPath).on('value', (snapshot) => {
                const raw = Number(snapshot?.val());
                if (!Number.isFinite(raw) || raw <= 0) return;
                if (raw <= RealtimeSyncState.lastSeenTs) return;
                RealtimeSyncState.lastSeenTs = raw;

                const ownTs = Number(RealtimeSyncState.lastOwnWriteTs || 0);
                const ignoreOwnWindowMs = Number(CONFIG.SYNC?.IGNORE_OWN_EVENT_MS || 2000);
                if (ownTs && Math.abs(raw - ownTs) <= ignoreOwnWindowMs) return;
                if (!RuntimeState.hasCurrentUser()) return;

                scheduleRealtimeRefresh_('firebase');
            }, (error) => {
                console.warn('Realtime sync listener error:', error);
            });

            RealtimeSyncState.isListening = true;
        }

        function scheduleRealtimeRefresh_(reason = 'firebase') {
            if (!RuntimeState.hasCurrentUser()) return;

            const delayMs = Number(CONFIG.SYNC?.RELOAD_DEBOUNCE_MS || 700);
            if (RealtimeSyncState.refreshTimer) {
                clearTimeout(RealtimeSyncState.refreshTimer);
            }

            RealtimeSyncState.refreshTimer = setTimeout(() => {
                RealtimeSyncState.refreshTimer = null;
                runRealtimeRefresh_(reason);
            }, delayMs);
        }

        function runRealtimeRefresh_(reason = 'firebase') {
            if (!RuntimeState.hasCurrentUser()) return;
            if (RealtimeSyncState.refreshInFlight) {
                RealtimeSyncState.refreshQueued = true;
                return;
            }

            RealtimeSyncState.refreshInFlight = true;
            // Не сбрасываем in-flight загрузку, чтобы не запускать гонки двух параллельных loadData.
            const activeLoad = RuntimeState.getDataLoadPromise();
            const tasks = [activeLoad || loadData()];
            if (isInspectorRole_()) {
                tasks.push(syncWorkDayStateFromServer_({ force: true, silent: true }).catch(() => null));
            }

            Promise.allSettled(tasks)
                .finally(() => {
                    RealtimeSyncState.refreshInFlight = false;
                    if (RealtimeSyncState.refreshQueued) {
                        RealtimeSyncState.refreshQueued = false;
                        scheduleRealtimeRefresh_('queued');
                    }
                });
        }

        function notifyRealtimeSync_(reason = 'change') {
            if (!RealtimeSyncState.database) return;

            const syncPath = RealtimeSyncState.path || String(CONFIG.SYNC?.PATH || 'sync/lastUpdate');
            const stamp = Date.now();
            RealtimeSyncState.lastOwnWriteTs = stamp;
            if (stamp > RealtimeSyncState.lastSeenTs) {
                RealtimeSyncState.lastSeenTs = stamp;
            }

            RealtimeSyncState.database.ref(syncPath).set(stamp)
                .catch((error) => {
                    console.warn('Realtime sync notify failed:', reason, error);
                });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            firebase.initializeApp(CONFIG.FIREBASE);
            initRealtimeSync_();
            initDelegatedEvents_();
            syncViewportHeight_();
            syncMobileLayoutState_();
            window.addEventListener('resize', () => {
                syncViewportHeight_();
                scheduleMenuIndicatorSync_();
                syncMobileLayoutState_();
            });
            window.addEventListener('orientationchange', () => {
                setTimeout(syncViewportHeight_, 120);
            });
            window.addEventListener('pageshow', () => {
                setTimeout(syncViewportHeight_, 60);
            });
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', syncViewportHeight_);
                window.visualViewport.addEventListener('scroll', syncViewportHeight_);
            }
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    setMobileFabExpanded_(false);
                    setMapInlineSearchOpen_(false);
                }
                if (event.key === 'Enter' && event.target && event.target.id === 'mapInlineSearchInput') {
                    event.preventDefault();
                    submitMapInlineSearch_();
                }
            });
            
            if (isLoggedIn) {
                // Пользователь авторизован: показываем приложение сразу
                RuntimeState.setCurrentUser(bootSession.user);
                RuntimeState.setSessionToken(bootSession.sessionToken);
                updateUserCard();
                initWorkDayStateForCurrentUser_({ force: true, silent: true });
                initMap();
                loadDataWithRetry_({ attempts: 3, retryDelayMs: 800, reason: 'boot' })
                    .catch((error) => {
                        console.error('Initial data load failed:', error);
                        showNotification('Ошибка загрузки данных. Проверьте сеть или обновите страницу', 'error');
                    });
                scheduleMenuIndicatorSync_();
            } else {
                // Пользователь не авторизован: показываем оверлей входа
                const overlay = document.getElementById('authOverlay');
                overlay.classList.remove('hidden');
                
                // Подключаем обработчики событий
                const passwordInput = document.getElementById('authPassword');
                const rememberInput = document.getElementById('authRemember');
                applyRememberedAuthToForm_();
                passwordInput.focus();
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') doLogin();
                });
                passwordInput.addEventListener('input', () => {
                    if (rememberInput && rememberInput.checked) {
                        persistRememberedAuth_(passwordInput.value, true);
                    }
                });
                if (rememberInput) {
                    rememberInput.addEventListener('change', () => {
                        persistRememberedAuth_(passwordInput.value, rememberInput.checked);
                    });
                }
            }
        });
        
        // Функциональность перетаскивания нижнего меню с поддержкой MutationObserver
        (function () {
            let listenersAttached = false;
            let isDragging = false;
            let dragInputType = '';
            let currentIndex = 0;
            
            /**
             * Инициализировать интерактивность стеклянного меню
             * Настраивает перетаскивание индикатора меню
             * @returns {boolean} Успешно ли инициализировано
             */
            function initGlassInteractions() {
                if (listenersAttached) return true;
                
                const menu = document.querySelector('.modern-menu');
                if (!menu) return false;
                
                const indicator = menu.querySelector('.menu-indicator');
                const indicatorInner = menu.querySelector('.menu-indicator-inner');
                if (!indicator) return false;
                

                
                // Логика перетаскивания стеклянного индикатора меню
                const buttons = menu.querySelectorAll('.modern-menu-btn');
                const tabCount = buttons.length;
                
                /**
                 * Обновить позицию индикатора меню
                 * @param {number} index - Индекс активной кнопки
                 * @param {boolean} [animate=true] - Использовать ли анимацию
                 */
                function updateIndicator(index, animate = true) {
                    currentIndex = Math.max(0, Math.min(index, tabCount - 1));
                    const activeBtn = buttons[currentIndex];
                    if (!activeBtn) return;
                    
                    if (animate) {
                        indicator.style.transition = 'all 0.25s cubic-bezier(0.25, 1, 0.5, 1)';
                        if (indicatorInner) {
                            indicatorInner.style.transition = 'left 0.25s cubic-bezier(0.25, 1, 0.5, 1)';
                        }
                    } else {
                        indicator.style.transition = 'none';
                        if (indicatorInner) {
                            indicatorInner.style.transition = 'none';
                        }
                    }
                    
                    indicator.style.width = `${activeBtn.offsetWidth}px`;
                    indicator.style.left = `${activeBtn.offsetLeft}px`;
                    
                    if (indicatorInner) {
                        indicatorInner.style.width = `${menu.offsetWidth}px`;
                        indicatorInner.style.left = `-${activeBtn.offsetLeft}px`;
                    }
                    
                    // Обновить активные состояния кнопок
                    buttons.forEach((btn, i) => {
                        btn.classList.toggle('active', i === currentIndex);
                    });
                }
                
                function extractClientX_(e) {
                    if (!e) return null;
                    if (typeof e.clientX === 'number') return e.clientX;
                    const touches = e.touches;
                    if (touches && touches.length) return touches[0].clientX;
                    const changedTouches = e.changedTouches;
                    if (changedTouches && changedTouches.length) return changedTouches[0].clientX;
                    return null;
                }

                /**
                 * Обновить положение индикатора по координате X.
                 * Возвращает индекс ближайшей вкладки.
                 */
                function updateIndicatorByClientX_(clientX) {
                    if (clientX === null) return currentIndex;
                    const rect = menu.getBoundingClientRect();
                    const relativeX = clientX - rect.left;
                    const percentage = Math.max(0, Math.min(1, relativeX / rect.width));
                    const btnWidth = rect.width / tabCount;
                    const pixelPosition = percentage * rect.width - (btnWidth / 2);

                    const clampedLeft = Math.max(0, Math.min(pixelPosition, rect.width - btnWidth));
                    indicator.style.left = `${clampedLeft}px`;
                    if (indicatorInner) {
                        indicatorInner.style.left = `-${clampedLeft}px`;
                    }

                    return Math.round(percentage * (tabCount - 1));
                }

                /**
                 * Обработчик начала перетаскивания
                 */
                function beginDragging_(e, inputType) {
                    const clientX = extractClientX_(e);
                    if (clientX === null) return;

                    isDragging = true;
                    dragInputType = inputType || '';
                    indicator.style.transition = 'none';
                    if (indicatorInner) {
                        indicatorInner.style.transition = 'none';
                    }
                    if (dragInputType === 'touch') {
                        e.preventDefault();
                    }
                    updateIndicatorByClientX_(clientX);
                }

                /**
                 * Обработчик движения при перетаскивании
                 */
                function handleMove(e) {
                    if (!isDragging) return;
                    const clientX = extractClientX_(e);
                    if (clientX === null) return;
                    if (dragInputType === 'touch') {
                        e.preventDefault();
                    }
                    updateIndicatorByClientX_(clientX);
                }

                /**
                 * Обработчик окончания перетаскивания
                 */
                function handleEnd(e) {
                    if (!isDragging) return;
                    const clientX = extractClientX_(e);
                    isDragging = false;
                    const newIndex = updateIndicatorByClientX_(clientX);
                    updateIndicator(newIndex, true);

                    const targetBtn = buttons[currentIndex];
                    if (targetBtn) {
                        const tabName = targetBtn.id.replace('btn-', '');
                        if (tabName) {
                            switchNav(tabName);
                        }
                    }
                }

                // Подключить события перетаскивания (мышь + touch).
                indicator.addEventListener('mousedown', (e) => beginDragging_(e, 'mouse'));
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);

                indicator.addEventListener('touchstart', (e) => beginDragging_(e, 'touch'), { passive: false });
                document.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('touchend', handleEnd, { passive: true });
                document.addEventListener('touchcancel', handleEnd, { passive: true });
                
                listenersAttached = true;
                return true;
            }
            
            // Пробуем инициализировать сразу
            if (initGlassInteractions()) return;
            
            // Если DOM еще не готов, наблюдаем за изменениями
            const observer = new MutationObserver(() => {
                if (initGlassInteractions()) {
                    observer.disconnect();
                }
            });
            
            observer.observe(document.body, { childList: true, subtree: true });
            
            // Защитный сценарий: отключаем наблюдатель через 5 секунд
            setTimeout(() => observer.disconnect(), 5000); // Резервный таймаут для MutationObserver
        })();
        
        // ============================================
        // Модуль авторизации
        // ============================================
        
        /**
         * Выполнить вход через JSONP-запрос к GAS
         * Проверяет пароль и инициализирует сессию
         */
        async function sha256HexClient_(text) {
            const data = new TextEncoder().encode(String(text || ''));
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function doLogin() {
            const passwordInput = document.getElementById('authPassword');
            const rememberInput = document.getElementById('authRemember');
            const errorDiv = document.getElementById('authError');
            const btn = document.querySelector('.auth-btn');
            const password = passwordInput.value.trim();
            const remember = !!(rememberInput && rememberInput.checked);
            
            if (!password) {
                showAuthError('Введите пароль');
                passwordInput.classList.add('error');
                setTimeout(() => passwordInput.classList.remove('error'), 500);
                return;
            }
            
            // Показать состояние загрузки
            btn.classList.add('loading');
            btn.disabled = true;
            errorDiv.classList.remove('show');

            try {
                const nonceResponse = await createJsonpRequest({ action: 'authNonce' }, 10000);
                if (!nonceResponse?.success || !nonceResponse?.nonceId || !nonceResponse?.nonce) {
                    throw new Error(nonceResponse?.error || 'Не удалось получить nonce');
                }

                const proof = await sha256HexClient_(`${password}|${nonceResponse.nonce}`);
                const authResponse = await createJsonpRequest({
                    action: 'auth',
                    nonceId: nonceResponse.nonceId,
                    proof: proof,
                    remember: remember ? '1' : '0'
                }, 15000);

                if (authResponse?.success && authResponse?.user && authResponse?.sessionToken) {
                    RuntimeState.setCurrentUser(authResponse.user);
                    RuntimeState.setSessionToken(authResponse.sessionToken);
                    persistSession_({
                        user: authResponse.user,
                        sessionToken: authResponse.sessionToken,
                        expiresAt: authResponse.expiresAt || ''
                    }, { remember });
                    persistRememberedAuth_(password, remember);
                    showSuccessAndContinue();
                    return;
                }

                showAuthError(authResponse?.error || 'Неверный пароль');
                passwordInput.classList.add('error');
                setTimeout(() => passwordInput.classList.remove('error'), 500);
                passwordInput.focus();
            } catch (error) {
                showAuthError(error?.message || 'Ошибка соединения с сервером');
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        }
        
        /**
         * Отобразить сообщение об ошибке авторизации
         * @param {string} message - Текст ошибки для отображения
         */
        function showAuthError(message) {
            const errorDiv = document.getElementById('authError');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }
        
        /**
         * Скрыть оверлей авторизации и инициализировать основное приложение
         */
        function showSuccessAndContinue() {
            hideAuthOverlay();
            updateUserCard();
            initWorkDayStateForCurrentUser_({ force: true, silent: true });
            initMap();
            RuntimeState.clearDataLoadPromise();
            loadDataWithRetry_({ attempts: 3, retryDelayMs: 800, reason: 'post-login' })
                .catch((error) => {
                    console.error('Post-login data load failed:', error);
                    showNotification('Ошибка загрузки данных. Попробуйте ещё раз', 'error');
                });
            scheduleMenuIndicatorSync_();
            syncMobileLayoutState_();
        }
        
        /**
         * Скрыть оверлей авторизации с анимацией
         */
        function hideAuthOverlay() {
            const overlay = document.getElementById('authOverlay');
            overlay.classList.add('hidden');
        }
        
        /**
         * Обновить отображение информации о пользователе в сайдбаре
         */
        function updateUserCard() {
            if (!RuntimeState.hasCurrentUser()) return;
            
            const userRole = document.querySelector('.user-role');
            const userName = document.querySelector('.user-name');
            const userEmoji = document.querySelector('.user-emoji');
            const currentUser = RuntimeState.getCurrentUser();
            
            debugLog('👤 updateUserCard:', currentUser);
            
            if (userRole && currentUser.role) userRole.textContent = currentUser.role + ':';
            if (userName && currentUser.name) userName.textContent = currentUser.name;
            if (userEmoji) {
                const style = getInspectorStyle(currentUser.name);
                userEmoji.textContent = style.icon || CONFIG.DEFAULTS?.INSPECTOR_ICON || '👤';
            }
            applyRoleVisibility_();
            renderWorkDayStatusUi_();
        }
        
        /**
         * Выйти из системы и сбросить состояние приложения
         */
        function logout() {
            if (!confirm('Выйти из системы?')) return;
            
            // Очистить сессию
            clearStoredSession_();
            RuntimeState.clearDataLoadPromise();
            RuntimeState.clearCurrentUser();
            RuntimeState.clearSessionToken();
            RuntimeState.clearMapSearchQuery();
            syncSearchInputsValue_('');
            closeMobileSidebar_();
            setMapInlineSearchOpen_(false);
            resetWorkDayState_();
            applyRoleVisibility_();
            
            // Сбросить карту
            MapState.destroyMapInstance();
            MapState.setHomesLayer(null);
            DataState.clearInspectorsHomesData();
            DataState.setInspectorsConfig({});
            DataState.clearInspectorsWorkDay();
            DataState.clearInspectorMessages();
            
            // Восстановить поле пароля/чекбокс из сохраненного состояния
            applyRememberedAuthToForm_();
            const passwordInput = document.getElementById('authPassword');
            
            // Скрыть ошибку
            const errorDiv = document.getElementById('authError');
            if (errorDiv) errorDiv.classList.remove('show');
            
            // Показать оверлей авторизации
            const overlay = document.getElementById('authOverlay');
            if (overlay) overlay.classList.remove('hidden');
            
            // Установить фокус в поле пароля
            if (passwordInput) {
                setTimeout(() => passwordInput.focus(), 100);
            }
        }

        function formatWorkDayTime_(rawValue) {
            const raw = String(rawValue || '').trim();
            if (!raw) return '';
            const hhmm = raw.match(/^(\d{2}:\d{2})/);
            if (hhmm) return hhmm[1];

            const parsed = new Date(raw);
            if (!isNaN(parsed.getTime())) {
                return parsed.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            }
            return raw;
        }

        function resetWorkDayState_() {
            WorkDayRuntimeState.reset();
            renderWorkDayStatusUi_();
        }

        function renderWorkDayStatusUi_() {
            const section = UIState.getDomById('workDaySection');
            const wrapper = UIState.getDomById('workDayControlWrapper');
            const statusDot = UIState.getDomById('workDayStatusDot');
            const statusText = UIState.getDomById('workDayStatusText');
            const toggle = UIState.getDomById('workDayToggle');

            if (!section || !statusText || !statusDot || !toggle) return;
            if (!isInspectorRole_()) {
                section.style.display = 'none';
                toggle.checked = false;
                toggle.disabled = true;
                return;
            }

            section.style.display = '';
            if (wrapper) wrapper.classList.remove('open', 'pending');

            const isLoaded = WorkDayRuntimeState.isLoaded();
            const isSyncing = WorkDayRuntimeState.isSyncing();
            const isOpen = WorkDayRuntimeState.isOpen();
            const lastError = WorkDayRuntimeState.getLastError();

            let nextText = 'Синхронизация...';
            let dotClass = 'workday-status-dot pending';
            let toggleChecked = false;
            let toggleDisabled = true;

            if (isSyncing) {
                nextText = 'Синхронизация...';
                dotClass = 'workday-status-dot pending';
            } else if (!isLoaded) {
                nextText = lastError ? 'Нет связи с сервером' : 'Обновление...';
                dotClass = 'workday-status-dot pending';
            } else if (isOpen) {
                const openTime = formatWorkDayTime_(WorkDayRuntimeState.getOpenTime());
                nextText = openTime ? `День открыт с ${openTime}` : 'День открыт';
                dotClass = 'workday-status-dot open';
                toggleChecked = true;
                toggleDisabled = false;
                if (wrapper) wrapper.classList.add('open');
            } else {
                nextText = 'День закрыт';
                dotClass = 'workday-status-dot closed';
                toggleChecked = false;
                toggleDisabled = false;
            }

            if (isSyncing) {
                toggleDisabled = true;
            }

            statusDot.className = dotClass;
            statusText.textContent = nextText;
            toggle.checked = toggleChecked;
            toggle.disabled = toggleDisabled;
            if (wrapper && isSyncing) wrapper.classList.add('pending');
        }

        function getCurrentGeoCoordsForWorkDay_() {
            if (!navigator.geolocation) return Promise.resolve('');

            return new Promise((resolve) => {
                let resolved = false;
                const done = (coords) => {
                    if (resolved) return;
                    resolved = true;
                    resolve(String(coords || '').trim());
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = Number(position.coords.latitude).toFixed(4);
                        const lon = Number(position.coords.longitude).toFixed(4);
                        done(`${lat}, ${lon}`);
                    },
                    () => done(''),
                    { enableHighAccuracy: true, timeout: 12000, maximumAge: 60000 }
                );

                setTimeout(() => done(''), 13000);
            });
        }

        function syncWorkDayStateFromServer_(options = {}) {
            if (!isInspectorRole_()) return Promise.resolve(null);

            const force = !!options.force;
            const silent = !!options.silent;
            const inspectorNorm = normalizeInspectorName_(RuntimeState.getCurrentUserName(''));
            const recentlySynced = Date.now() - WorkDayRuntimeState.getLastSyncAt() < 12000;
            const sameInspector = inspectorNorm && inspectorNorm === WorkDayRuntimeState.getLastSyncInspectorNorm();

            if (!force && !WorkDayRuntimeState.isSyncing() && WorkDayRuntimeState.isLoaded() && recentlySynced && sameInspector) {
                renderWorkDayStatusUi_();
                return Promise.resolve(null);
            }

            WorkDayRuntimeState.setSyncing(true);
            WorkDayRuntimeState.clearError();
            renderWorkDayStatusUi_();

            return createJsonpRequest({ action: 'checkWorkDay' }, 20000)
                .then((result) => {
                    if (!result || !result.success) {
                        throw new Error(result?.error || 'Не удалось получить статус рабочего дня');
                    }

                    WorkDayRuntimeState.setLoaded(true);
                    WorkDayRuntimeState.setOpen(!!result.open);
                    WorkDayRuntimeState.setOpenTime(result.open ? (result.openTime || '') : '');
                    WorkDayRuntimeState.clearError();
                    WorkDayRuntimeState.markSynced(inspectorNorm);
                    return result;
                })
                .catch((error) => {
                    WorkDayRuntimeState.setLoaded(false);
                    WorkDayRuntimeState.setOpen(false);
                    WorkDayRuntimeState.setOpenTime('');
                    WorkDayRuntimeState.setLastError(error?.message || 'Ошибка синхронизации');
                    if (!silent) {
                        showNotification('❌ ' + WorkDayRuntimeState.getLastError(), 'error');
                    }
                    throw error;
                })
                .finally(() => {
                    WorkDayRuntimeState.setSyncing(false);
                    renderWorkDayStatusUi_();
                });
        }

        function initWorkDayStateForCurrentUser_(options = {}) {
            if (!isInspectorRole_()) {
                resetWorkDayState_();
                return Promise.resolve(null);
            }
            WorkDayRuntimeState.setLoaded(false);
            WorkDayRuntimeState.clearError();
            renderWorkDayStatusUi_();
            return syncWorkDayStateFromServer_({
                force: options.force !== false,
                silent: options.silent !== false
            }).catch(() => null);
        }

        async function applyWorkDayAction_(action, comment = '') {
            if (!isInspectorRole_()) {
                renderWorkDayStatusUi_();
                return;
            }
            if (WorkDayRuntimeState.isSyncing()) {
                renderWorkDayStatusUi_();
                return;
            }

            const actionName = action === 'end' ? 'endWorkDay' : 'startWorkDay';
            const desiredOpen = actionName === 'startWorkDay';
            const fallbackMessage = desiredOpen ? 'Не удалось открыть рабочий день' : 'Не удалось закрыть рабочий день';
            const noGeoMarker = String(CONFIG.WORKDAY_NO_GEO_MARKER || '').trim() || 'ГЕОЛОКАЦИЯ НЕДОСТУПНА: запросить селфи';
            let mustResync = false;
            let geoUnavailable = false;

            WorkDayRuntimeState.setSyncing(true);
            WorkDayRuntimeState.clearError();
            renderWorkDayStatusUi_();

            try {
                const coords = await getCurrentGeoCoordsForWorkDay_();
                const params = { action: actionName };
                const coordsValue = String(coords || '').trim();
                if (coordsValue) {
                    const parts = coordsValue.split(',');
                    const lat = String(parts[0] || '').trim();
                    const lon = String(parts[1] || '').trim();
                    params.coords = coordsValue;
                    if (lat) params.lat = lat;
                    if (lon) params.lon = lon;
                    if (actionName === 'startWorkDay') params.open_coordinates = coordsValue;
                    if (actionName === 'endWorkDay') params.close_coordinates = coordsValue;
                } else {
                    geoUnavailable = true;
                    if (actionName === 'startWorkDay') params.open_coordinates = noGeoMarker;
                    if (actionName === 'endWorkDay') params.close_coordinates = noGeoMarker;
                }

                const safeComment = String(comment || '').trim();
                if (safeComment) {
                    if (actionName === 'startWorkDay') params.open_comment = safeComment;
                    if (actionName === 'endWorkDay') params.close_comment = safeComment;
                }

                const response = await createJsonpRequest(params, 25000);
                if (!response || !response.success) {
                    const code = String(response?.code || '').toUpperCase();
                    if (code === 'ALREADY_OPEN' || code === 'ALREADY_CLOSED') {
                        mustResync = true;
                        showNotification('ℹ️ ' + (response?.error || 'Статус уже актуален'), 'info');
                        return;
                    }
                    throw new Error(response?.error || fallbackMessage);
                }
                if (!response.persisted) {
                    throw new Error('Сервер не подтвердил сохранение в таблице');
                }

                WorkDayRuntimeState.setLoaded(true);
                WorkDayRuntimeState.setOpen(!!response.open);
                WorkDayRuntimeState.setOpenTime(response.open ? (response.openTime || '') : '');
                WorkDayRuntimeState.clearError();
                WorkDayRuntimeState.markSynced(normalizeInspectorName_(RuntimeState.getCurrentUserName('')));
                notifyRealtimeSync_('workday');

                if (geoUnavailable) {
                    const statusLabel = response.open ? 'Рабочий день открыт' : 'Рабочий день закрыт';
                    showNotification(`⚠️ ${statusLabel}. Геолокация недоступна, статус сохранен без координат`, 'info');
                } else {
                    showNotification(response.open ? '🟢 Рабочий день открыт' : '🔴 Рабочий день закрыт', 'success');
                }
            } catch (error) {
                mustResync = true;
                WorkDayRuntimeState.setLastError(error?.message || fallbackMessage);
                showNotification('❌ ' + WorkDayRuntimeState.getLastError(), 'error');
            } finally {
                WorkDayRuntimeState.setSyncing(false);
                renderWorkDayStatusUi_();
                if (mustResync) {
                    syncWorkDayStateFromServer_({ force: true, silent: true }).catch(() => null);
                }
            }
        }

        function handleWorkDayToggleChange_(target) {
            if (!(target instanceof HTMLInputElement)) return;

            const currentOpen = WorkDayRuntimeState.isOpen();
            const desiredOpen = !!target.checked;
            target.checked = currentOpen;

            if (!isInspectorRole_()) {
                showNotification('❌ Доступно только для роли "Инспектор"', 'error');
                renderWorkDayStatusUi_();
                return;
            }
            if (!WorkDayRuntimeState.isLoaded() || WorkDayRuntimeState.isSyncing()) {
                renderWorkDayStatusUi_();
                return;
            }
            if (desiredOpen === currentOpen) {
                renderWorkDayStatusUi_();
                return;
            }

            const question = desiredOpen ? 'Открыть рабочий день?' : 'Закрыть рабочий день?';
            if (!window.confirm(question)) {
                renderWorkDayStatusUi_();
                return;
            }

            const comment = window.prompt('Комментарий (необязательно):', '') || '';
            applyWorkDayAction_(desiredOpen ? 'start' : 'end', comment);
        }
        
        // ============================================
        // Модуль карты
        // ============================================
        
        /**
         * Инициализировать Яндекс.Карты
         * Настраивает центр карты, зум, контролы и слои
         */
        function initMap() {
            ymaps.ready(() => {
                MapState.setMapInstance(new ymaps.Map('map', {
                    center: [55.7558, 37.6176],
                    zoom: 10,
                    controls: ['zoomControl', 'typeSelector']
                }));
                scheduleMapFitToViewport_();
                setTimeout(scheduleMapFitToViewport_, 120);
                
                // Инициализируем менеджеры объектов (ObjectManager) для точек
                initObjectManagers_();
                
                // Слой для домашних адресов инспекторов
                MapState.setHomesLayer(new ymaps.GeoObjectCollection());
                MapState.getMapInstance().geoObjects.add(MapState.getHomesLayer());

                // Догоняющий рендер: если данные пришли раньше готовности слоев карты.
                scheduleMapUpdate_();
            });
        }
        
        /**
         * Переключить видимость домов инспекторов на карте
         */
        async function showHomes() {
            if (isInspectorRole_()) return;
            // Если данных нет — сначала загрузить
            if (Object.keys(DataState.getInspectorsHomesData()).length === 0) {
                try {
                    await loadData();
                } catch (error) {
                    showNotification('Ошибка загрузки домов: ' + error.message, 'error');
                    return;
                }
            }
            
            const visible = UIState.toggleInspectorsHomesVisible();
            debugLog('🏠 Дома инспекторов:', visible ? 'показаны' : 'скрыты');
            updateInspectorsHomesLayer();
        }
        
        /**
         * Обновить слой домов инспекторов в зависимости от текущего UI-состояния.
         * Добавляет/удаляет метки с карты
         */
        function updateInspectorsHomesLayer() {
            const homesLayer = MapState.getHomesLayer();
            if (!homesLayer) return;
            
            homesLayer.removeAll();
            
            if (!UIState.isInspectorsHomesVisible()) return;
            
            const homes = DataState.getInspectorsHomesData();
            const keys = Object.keys(homes);
            
            if (keys.length === 0) {
                alert('⚠️ Нет данных о домах инспекторов');
                return;
            }
            
            keys.forEach(inspector => {
                const home = homes[inspector];
                if (!home || !home.lat || !home.lon) return;
                const style = getInspectorStyle(inspector);
                const homeColor = style.color || CONFIG.DEFAULTS?.INSPECTOR_COLOR || '#1f6fb2';
                
                const placemark = new ymaps.Placemark(
                    [home.lat, home.lon],
                    {
                        balloonContent: `<b>🏠 ${inspector}</b><br>Домашний адрес`
                    },
                    {
                        preset: 'islands#blueHomeIcon',
                        iconColor: homeColor
                    }
                );
                
                homesLayer.add(placemark);
            });
        }
        
        // ============================================
        // Модуль данных
        // ============================================
        
        /**
         * Загрузить данные из Google Apps Script через JSONP.
         * @returns {Promise} Промис с данными
         */
        function loadData() {
            // Если загрузка уже идет, возвращаем текущий промис
            if (RuntimeState.getDataLoadPromise()) return RuntimeState.getDataLoadPromise();
            
            RuntimeState.setDataLoadPromise(new Promise((resolve, reject) => {
                const callbackName = 'cb_' + Date.now() + '_' + Math.random().toString(36).slice(2, 10);
                const script = document.createElement('script');
                let timeoutId;
                
                const cleanup = () => {
                    clearTimeout(timeoutId);
                    if (script.parentNode) document.head.removeChild(script);
                    try { delete window[callbackName]; } catch(e) {}
                };
                
                // Таймаут 15 секунд
                timeoutId = setTimeout(() => {
                    RuntimeState.clearDataLoadPromise();
                    cleanup();
                    reject(new Error('Таймаут загрузки данных'));
                }, 15000);
                
                window[callbackName] = function(data) {
                    cleanup();
                    
                    if (data?.success) {
                        // Сохраняем точки из 3 листов (Map, Laboratory, ConstructionControl)
                        if (data.points) {
                            DataState.setObjectsData(data.points);
                            debugLog('✅ Загружено точек:', DataState.getObjectsData().length);
                        }
                        
                        if (data.inspectorsHomes) {
                            DataState.setInspectorsHomesData(data.inspectorsHomes);
                            debugLog('✅ Загружено домов:', Object.keys(DataState.getInspectorsHomesData()).length);
                        }
                        if (data.inspectorsConfig) {
                            DataState.setInspectorsConfig(data.inspectorsConfig);
                        }
                        DataState.setInspectorsWorkDay(data.inspectorsWorkDay);
                        DataState.setInspectorMessages(data.inspectorMessages);
                        
                        // Заполняем список инспекторов для рендера фильтров
                        // Приоритет: data.inspectorsList (содержит поле division) > data.inspectorsConfig (содержит цвет/иконку)
                        if (data.inspectorsList && Array.isArray(data.inspectorsList)) {
                            const inspectorsList = data.inspectorsList.map(insp => {
                                const config = (DataState.getInspectorsConfig() && DataState.getInspectorsConfig()[insp.name]) || {};
                                return {
                                    ...insp,
                                    ...config,
                                    // Гарантируем наличие поля division; если его нет, используем 'Прочие'
                                    division: insp.division || config.division || 'Прочие'
                                };
                            });
                            DataState.setInspectorsList(inspectorsList);
                        } else if (DataState.getInspectorsConfig()) {
                            // Резервный сценарий, если сервер не вернул data.inspectorsList
                            const inspectorsList = Object.keys(DataState.getInspectorsConfig()).map(name => ({
                                name: name,
                                division: DataState.getInspectorsConfig()[name].division || 'Прочие',
                                ...DataState.getInspectorsConfig()[name]
                            }));
                            DataState.setInspectorsList(inspectorsList);
                        }
                        
                        // Сортировка инспекторов по имени
                        DataState.getInspectorsList().sort((a, b) => a.name.localeCompare(b.name));
                            
                        debugLog('✅ Загружено инспекторов:', DataState.getInspectorsList().length);
                        
                        // Важно: карту рендерим после загрузки конфигурации инспекторов,
                        // чтобы маркеры сразу получили цвет/иконку своего инспектора.
                        scheduleMapUpdate_();
                        // Страховочный второй проход рендера (устраняет редкие стартовые гонки стилей/слоев).
                        setTimeout(scheduleMapUpdate_, 180);
                        updateUserCard();
                        
                        // ⭐ Авто-рендер открытых панелей
                        autoRenderOpenPanels();
                        
                        // Рендер списков в боковой панели
                        renderInspectorMessages_();
                        renderFilterLists();
                        refreshInspectorManagementWorkDayIndicators_();
                        filterManagementInspectors();
                        
                        // Промис нужен только для дедупликации текущей загрузки.
                        // После успеха очищаем, чтобы будущие вызовы могли сделать fresh-load.
                        RuntimeState.clearDataLoadPromise();
                        resolve(data);
                    } else {
                        if (data?.code === 'UNAUTHORIZED') {
                            clearStoredSession_();
                            RuntimeState.clearCurrentUser();
                            RuntimeState.clearSessionToken();
                            const overlay = document.getElementById('authOverlay');
                            if (overlay) overlay.classList.remove('hidden');
                        }
                        RuntimeState.clearDataLoadPromise();
                        reject(new Error(data?.error || 'Ошибка загрузки'));
                    }
                };
                
                script.onerror = () => {
                    RuntimeState.clearDataLoadPromise();
                    cleanup();
                    reject(new Error('Ошибка соединения'));
                };
                
                const sessionToken = RuntimeState.getSessionToken();
                const tokenQuery = sessionToken ? '&sessionToken=' + encodeURIComponent(sessionToken) : '';
                const nowLocal = new Date();
                const dd = String(nowLocal.getDate()).padStart(2, '0');
                const mm = String(nowLocal.getMonth() + 1).padStart(2, '0');
                const yyyy = String(nowLocal.getFullYear());
                const dateTokenQuery = '&dateToken=' + encodeURIComponent(`${dd}.${mm}.${yyyy}`);
                script.src = CONFIG.SCRIPT_URL + '?action=getData&callback=' + callbackName + tokenQuery + dateTokenQuery;
                document.head.appendChild(script);
            }));
            
            return RuntimeState.getDataLoadPromise();
        }

        /**
         * Загрузить данные с ограниченными повторными попытками.
         * Используется на старте/после логина для сглаживания редких сбоев JSONP.
         * @param {{attempts?:number,retryDelayMs?:number,reason?:string}} options
         * @returns {Promise<any>}
         */
        function loadDataWithRetry_(options = {}) {
            const attempts = Math.max(1, Number(options.attempts) || 3);
            const retryDelayMs = Math.max(200, Number(options.retryDelayMs) || 800);
            const reason = String(options.reason || 'generic');
            let attempt = 0;

            const run = () => {
                attempt += 1;
                if (attempt > 1) {
                    RuntimeState.clearDataLoadPromise();
                }
                return loadData().catch((error) => {
                    if (attempt >= attempts) throw error;
                    const waitMs = retryDelayMs * attempt;
                    console.warn(`loadData retry ${attempt}/${attempts} failed (${reason}):`, error);
                    return new Promise((resolve) => setTimeout(resolve, waitMs)).then(run);
                });
            };

            return run();
        }
        
        /**
         * Автоматически отрисовать открытые панели при получении данных
         * Вызывается после успешной загрузки данных
         */
        function autoRenderOpenPanels() {
            // Панель управления инспекторами
            const inspectorPanel = document.getElementById('inspectorManagementPanel');
            if (inspectorPanel && !inspectorPanel.classList.contains('hidden')) {
                // В открытой панели не делаем авто-перерисовку на фоновых sync/loadData:
                // на iPhone это вызывает тяжёлые перерисовки и может приводить к reload страницы.
                return;
            }
        }
        
        const DIVISION_MAPPING = {
            'Map': 'ГС',
            'DMS': 'ДМС',
            'ConstructionControl': 'СК',
            'Laboratory': 'Лаборатория'
        };


        
        // ============================================
        // Модуль интерфейса
        // ============================================
        
        // ============================================
        // Синглтон стеклянных уведомлений
        // ============================================
        
        const GlassNotification = {
            /** @type {HTMLElement|null} Текущее уведомление */
            current: null,
            /** @type {number|null} ID таймаута авто-скрытия */
            timeoutId: null,
            
            /**
             * Показать уведомление (заменяет предыдущее)
             * @param {string} message - Текст сообщения
             * @param {'success'|'error'|'info'|'warning'} type - Тип уведомления
             * @param {number} [duration=4000] - Длительность показа в мс
             */
            show(message, type = 'success', duration = (typeof CONFIG !== 'undefined' && CONFIG.ANIMATION?.NOTIFICATION_DURATION) || 4000) {
                // Сбросить таймер предыдущего
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
                
                // Удалить предыдущее уведомление
                if (this.current) {
                    const old = this.current;
                    old.classList.remove('show');
                    setTimeout(() => old.remove(), 300); // Animation cleanup delay
                }
                
                // Иконка по типу
                const icons = {
                    success: '✅',
                    error: '❌',
                    warning: '⚠️',
                    info: 'ℹ️'
                };
                const icon = icons[type] || icons.info;
                
                // Очистить сообщение от эмодзи
                const cleanMessage = message
                    .replace(/[✅❌⚠️ℹ️🔄]/g, '')
                    .trim();
                
                // Создать новое уведомление
                const el = document.createElement('div');
                el.className = 'glass-notification';
                el.innerHTML = `
                    <span class="glass-notification-icon">${icon}</span>
                    <span class="glass-notification-text">${cleanMessage}</span>
                `;
                
                document.body.appendChild(el);
                this.current = el;
                
                // Анимация появления
                requestAnimationFrame(() => {
                    el.classList.add('show');
                });
                
                // Авто-скрытие
                this.timeoutId = setTimeout(() => {
                    this.hide();
                }, duration);
            },
            
            /**
             * Скрыть текущее уведомление
             */
            hide() {
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
                
                if (this.current) {
                    const el = this.current;
                    el.classList.remove('show');
                    el.classList.add('swipe-out');
                    setTimeout(() => {
                        if (el.parentNode) el.remove();
                    }, 300);
                    this.current = null;
                }
            },
            
        };
        
        /**
         * Показать уведомление (обёртка для совместимости)
         * @param {string} message - Текст сообщения
         * @param {'success'|'error'|'info'|'warning'} type - Тип уведомления
         */
        function showNotification(message, type = 'success') {
            GlassNotification.show(message, type);
        }
        
        // ============================================
        // Модуль утилит
        // ============================================
        
        const Utils = (() => {
            /**
             * Форматировать дату для отображения с обработкой ошибок.
             * @param {string|Date|number} dateInput - Строка даты, объект Date или timestamp
             * @param {Object} [options={}] - Параметры форматирования
             * @param {string} [options.fallback='—'] - Значение при некорректной дате
             * @param {boolean} [options.includeTime=true] - Включать ли время в вывод
             * @returns {string} Отформатированная дата или fallback
             * @example
             * Utils.formatDate('2024-01-15'); // "15.01.2024, 00:00"
             * Utils.formatDate(null); // "—"
             * Utils.formatDate('invalid'); // "invalid" (если вход был строкой)
             */
            const formatDate = (dateInput, options = {}) => {
                const { fallback = '—', includeTime = true } = options;
                
                // Обработка пустого значения (null/undefined)
                if (dateInput === null || dateInput === undefined || dateInput === '') {
                    return fallback;
                }
                
                try {
                    const date = new Date(dateInput);
                    
                    // Проверка на невалидную дату
                    if (isNaN(date.getTime())) {
                        console.warn('Utils.formatDate: Invalid date input:', dateInput);
                        return typeof dateInput === 'string' ? dateInput : fallback;
                    }
                    
                    // Используем настройки даты из CONFIG, иначе значения по умолчанию
                    const locale = (typeof CONFIG !== 'undefined' && CONFIG.DATE?.LOCALE) || 'ru-RU';
                    const formatOptions = (typeof CONFIG !== 'undefined' && CONFIG.DATE?.FORMAT) || {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    };
                    
                    if (!includeTime) {
                        delete formatOptions.hour;
                        delete formatOptions.minute;
                    }
                    
                    return date.toLocaleString(locale, formatOptions);
                } catch (error) {
                    console.error('Utils.formatDate: Error formatting date:', error);
                    return fallback;
                }
            };
            
            /**
             * Форматировать дату как DD.MM.YYYY с обработкой ошибок.
             * @param {Date|string|number} [dateInput=new Date()] - Дата для форматирования
             * @param {Object} [options={}] - Параметры форматирования
             * @param {string} [options.fallback=''] - Значение при некорректной дате
             * @param {string} [options.separator='.'] - Разделитель частей даты
             * @returns {string} Строка DD.MM.YYYY или fallback
             * @example
             * Utils.formatDateRU(new Date(2024, 0, 15)); // "15.01.2024"
             * Utils.formatDateRU('invalid'); // ""
             */
            const formatDateRU = (dateInput = new Date(), options = {}) => {
                const { fallback = '', separator = '.' } = options;
                
                try {
                    const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
                    
                    if (isNaN(date.getTime())) {
                        console.warn('Utils.formatDateRU: Invalid date input:', dateInput);
                        return fallback;
                    }
                    
                    const dd = String(date.getDate()).padStart(2, '0');
                    const mm = String(date.getMonth() + 1).padStart(2, '0');
                    const yyyy = date.getFullYear();
                    
                    return `${dd}${separator}${mm}${separator}${yyyy}`;
                } catch (error) {
                    console.error('Utils.formatDateRU: Error formatting date:', error);
                    return fallback;
                }
            };
            
            /**
             * Скопировать текст в буфер обмена.
             * @param {string} text - Текст для копирования
             * @returns {Promise<boolean>}
             */
            const copyToClipboard = async (text) => {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch {
                    // Резервный путь для старых браузеров
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    const success = document.execCommand('copy');
                    document.body.removeChild(textarea);
                    return success;
                }
            };
            
            /**
             * Извлечь отображаемый ID из полного ID объекта.
             * @param {string} id - Полный ID (например, "Map_123")
             * @returns {string} Отображаемый ID (например, "123")
             */
            const extractDisplayId = (id) => {
                if (!id) return '';
                if (id.includes('_')) return id.split('_')[1];
                return id;
            };

            const escapeHtml = (value) => {
                return String(value ?? '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            };

            const escapeAttr = (value) => escapeHtml(value);

            const sanitizeUrl = (value) => {
                const raw = String(value ?? '').trim();
                if (!raw) return '';
                try {
                    const url = new URL(raw, window.location.origin);
                    if (url.protocol === 'http:' || url.protocol === 'https:') {
                        return url.href;
                    }
                } catch (_) {}
                return '';
            };
            
            /**
             * Ограничить частоту вызова функции (debounce).
             * @param {Function} fn - Функция для обертки
             * @param {number} ms - Задержка в миллисекундах
             * @returns {Function}
             */
            const debounce = (fn, ms = 300) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => fn(...args), ms);
                };
            };
            
            return {
                formatDate,
                formatDateRU,
                copyToClipboard,
                extractDisplayId,
                escapeHtml,
                escapeAttr,
                sanitizeUrl,
                debounce
            };
        })();
        
        /**
         * Переключить видимость секции фильтра
         * @param {string} id - ID секции фильтра ('lists' | 'inspectors')
         */
        function syncFilterPanelHeight_(panel) {
            if (!panel || !panel.classList.contains('open')) return;

            const vv = window.visualViewport;
            const viewportHeight = Math.round((vv && Number(vv.height)) || window.innerHeight || 0);
            const sidebarContent = document.querySelector('.sidebar-content');
            const sidebarHeight = sidebarContent ? sidebarContent.clientHeight : 0;

            // Ограничиваем высоту панели, чтобы она оставалась прокручиваемой и не "зажималась".
            const byViewport = viewportHeight > 0 ? Math.floor(viewportHeight * 0.62) : 420;
            const bySidebar = sidebarHeight > 0 ? Math.floor(sidebarHeight * 0.64) : byViewport;
            const nextHeight = Math.max(220, Math.min(byViewport, bySidebar));

            panel.style.setProperty('--filter-open-max-height', `${nextHeight}px`);
        }

        function toggleFilter(id) {
            const panel = document.getElementById('filter-' + id);
            if (!panel) return;
            panel.classList.toggle('open');
            syncFilterPanelHeight_(panel);
        }

        /**
         * Переключить аккордеон
         * @param {HTMLElement} header - Заголовок аккордеона
         */
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            if (!content) return;
            
            // Переключить класс активности
            content.classList.toggle('active');
            
            // Дополнительно: повернуть стрелку, если она есть
            const arrow = header.querySelector('.accordion-meta > .accordion-arrow, .accordion-meta > span:last-child');
            if (arrow) {
                arrow.style.transform = content.classList.contains('active') ? 'rotate(180deg)' : 'rotate(0deg)';
            }

            // При раскрытии внутренних блоков пересчитываем доступную высоту внешней панели.
            const parentFilterPanel = header.closest('.filter-content');
            if (parentFilterPanel) {
                requestAnimationFrame(() => syncFilterPanelHeight_(parentFilterPanel));
            }
        }

        /**
         * Рендер списков фильтрации (Объекты и Инспекторы)
         */
        function renderInspectorMessageList_(root, messages) {
            if (!root) return;
            root.innerHTML = '';
            const source = Array.isArray(messages) ? messages : [];
            if (!source.length) {
                const empty = document.createElement('div');
                empty.className = 'inspector-message-item inspector-message-item--empty';
                empty.textContent = 'Нет сообщений';
                root.appendChild(empty);
                return;
            }
            source.forEach(item => {
                const node = document.createElement('div');
                node.className = 'inspector-message-item';
                node.textContent = String(item?.message || '').trim();
                root.appendChild(node);
            });
        }

        function renderInspectorMessages_() {
            const section = document.getElementById('inspectorMessagesSection');
            const personalRoot = document.getElementById('inspectorMessagesIndividual');
            const groupRoot = document.getElementById('inspectorMessagesGroup');
            if (!section || !personalRoot || !groupRoot) return;

            if (!isInspectorRole_()) {
                section.style.display = 'none';
                return;
            }

            section.style.display = '';
            const payload = DataState.getInspectorMessages();
            renderInspectorMessageList_(personalRoot, payload.individual);
            renderInspectorMessageList_(groupRoot, payload.group);
        }

        /**
         * Рендер списков фильтрации (Объекты и Инспекторы)
         */
        function renderFilterLists() {
            const listsContainer = document.getElementById('lists-container');
            const inspectorsContainer = document.getElementById('inspectors-container');
            
            if (!listsContainer || !inspectorsContainer) return;
            
            listsContainer.innerHTML = '';
            inspectorsContainer.innerHTML = '';
            
            // 1. Группировка инспекторов по дивизионам
            const divisionMap = {
                'ГС': 'ГС',
                'Map': 'ГС',
                'ДМС': 'ДМС',
                'DMS': 'ДМС',
                'СК': 'СК',
                'ConstructionControl': 'СК',
                'Лаборатория': 'Лаборатория',
                'Laboratory': 'Лаборатория'
            };
            
            // Группируем инспекторов
            const inspectorsByDivision = {
                'ГС': [],
                'ДМС': [],
                'СК': [],
                'Лаборатория': [],
                'Прочие': []
            };
            const visibleInspectors = getRoleScopedInspectors_(DataState.getInspectorsList());
            const visibleObjects = getRoleScopedObjects_(DataState.getObjectsData());
            
            debugLog('Rendering inspectors, total:', visibleInspectors.length);
            
            visibleInspectors.forEach(insp => {
                if (!insp || typeof insp !== 'object') return;
                let rawDiv = insp.division;
                if (!rawDiv) rawDiv = 'Прочие';
                
                // Нормализация (trim)
                rawDiv = rawDiv.toString().trim();
                
                // Поиск маппинга
                let div = divisionMap[rawDiv] || divisionMap[Object.keys(divisionMap).find(k => k.toLowerCase() === rawDiv.toLowerCase())];
                
                if (!div) div = 'Прочие';
                
                if (!inspectorsByDivision[div]) inspectorsByDivision[div] = [];
                inspectorsByDivision[div].push(insp);
            });
            
            // Рендер инспекторов
            Object.keys(inspectorsByDivision).forEach(div => {
                const inspectors = inspectorsByDivision[div];
                if (inspectors.length === 0) return;
                
                const checkboxId = `chk-group-insp-${div}`;
                const accordion = createAccordion(div, inspectors.length, checkboxId, {
                    division: div,
                    type: 'inspectors'
                });
                const content = accordion.querySelector('.accordion-content');
                
                inspectors.forEach((insp, index) => {
                    const item = document.createElement('div');
                    item.className = 'checkbox-item';
                    const input = document.createElement('input');
                    const inputId = `insp-${encodeURIComponent(div)}-${index}`;
                    input.type = 'checkbox';
                    input.id = inputId;
                    input.value = insp.name;
                    input.dataset.division = div;
                    input.dataset.changeAction = 'update-map-filters';

                    const label = document.createElement('label');
                    label.setAttribute('for', inputId);
                    label.textContent = insp.name;

                    item.appendChild(input);
                    item.appendChild(label);
                    content.appendChild(item);
                });
                
                inspectorsContainer.appendChild(accordion);
            });
            if (!inspectorsContainer.children.length) {
                const emptyInspectors = document.createElement('div');
                emptyInspectors.className = 'filter-item';
                emptyInspectors.style.cursor = 'default';
                emptyInspectors.textContent = 'Нет доступных инспекторов';
                inspectorsContainer.appendChild(emptyInspectors);
            }
            
            // 2. Группировка списков объектов по полю list внутри источников
            const listsBySource = {
                'ГС': new Set(),
                'ДМС': new Set(),
                'СК': new Set(),
                'Лаборатория': new Set(),
                'Прочие': new Set()
            };
            
            visibleObjects.forEach(obj => {
                if (!obj || typeof obj !== 'object') return;
                const sourceName = CONFIG.SOURCES[obj.source] || obj.source;
                let div = divisionMap[sourceName] || 'Прочие';
                if (listsBySource[div]) {
                    listsBySource[div].add(getObjectListName_(obj));
                }
            });
            
            // Рендер списков объектов
            Object.keys(listsBySource).forEach(div => {
                const lists = Array.from(listsBySource[div]).sort();
                if (lists.length === 0) return;
                
                const checkboxId = `chk-group-list-${div}`;
                const accordion = createAccordion(div, lists.length, checkboxId, {
                    division: div,
                    type: 'lists'
                });
                const content = accordion.querySelector('.accordion-content');
                
                lists.forEach((listName, index) => {
                    const item = document.createElement('div');
                    item.className = 'checkbox-item';
                    const input = document.createElement('input');
                    const inputId = `list-${encodeURIComponent(div)}-${index}`;
                    input.type = 'checkbox';
                    input.id = inputId;
                    input.value = listName;
                    input.dataset.division = div;
                    input.dataset.changeAction = 'update-map-filters';

                    const label = document.createElement('label');
                    label.setAttribute('for', inputId);
                    label.textContent = listName;

                    item.appendChild(input);
                    item.appendChild(label);
                    content.appendChild(item);
                });
                
                listsContainer.appendChild(accordion);
            });
            if (!listsContainer.children.length) {
                const emptyLists = document.createElement('div');
                emptyLists.className = 'filter-item';
                emptyLists.style.cursor = 'default';
                emptyLists.textContent = 'Нет доступных списков объектов';
                listsContainer.appendChild(emptyLists);
            }

            UIState.setFilterCheckboxes(
                'inspectors',
                Array.from(inspectorsContainer.querySelectorAll('input[type="checkbox"][data-division][data-change-action="update-map-filters"]'))
            );
            UIState.setFilterCheckboxes(
                'lists',
                Array.from(listsContainer.querySelectorAll('input[type="checkbox"][data-division][data-change-action="update-map-filters"]'))
            );
            applyStoredFiltersToUI_();
            syncFilterPanelHeight_(document.getElementById('filter-lists'));
            syncFilterPanelHeight_(document.getElementById('filter-inspectors'));
        }
        
        /**
         * Загрузить сохраненные фильтры из localStorage
         * @returns {{inspectors: string[], lists: {name: string, division: string}[]} | null}
         */
        function loadStoredFilters_() {
            try {
                const raw = localStorage.getItem(CONFIG.FILTERS_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return null;
                return {
                    inspectors: Array.isArray(parsed.inspectors) ? parsed.inspectors : [],
                    lists: Array.isArray(parsed.lists) ? parsed.lists : []
                };
            } catch (err) {
                console.warn('⚠️ Не удалось прочитать сохраненные фильтры:', err);
                return null;
            }
        }

        /**
         * Сохранить фильтры в localStorage
         * @param {{inspectors: string[], lists: {name: string, division: string}[]}} filters
         */
        function saveFiltersToStorage_(filters) {
            try {
                localStorage.setItem(CONFIG.FILTERS_STORAGE_KEY, JSON.stringify(filters));
            } catch (err) {
                console.warn('⚠️ Не удалось сохранить фильтры:', err);
            }
        }

        /**
         * Применить сохраненные фильтры к чекбоксам после рендера
         */
        function applyStoredFiltersToUI_() {
            const stored = loadStoredFilters_();
            if (!stored) return;

            const cache = ensureFilterCheckboxCache_();
            const inspectorSet = new Set(Array.isArray(stored.inspectors) ? stored.inspectors : []);
            cache.inspectors.forEach(cb => {
                cb.checked = inspectorSet.has(cb.value);
            });

            const storedLists = Array.isArray(stored.lists) ? stored.lists : [];
            cache.lists.forEach(cb => {
                const match = storedLists.some(item => item && item.name === cb.value && item.division === cb.dataset.division);
                cb.checked = match;
            });

            updateMapFilters();
        }

        /**
         * Синхронизировать чекбоксы групп (в заголовках аккордеонов)
         * с состоянием дочерних чекбоксов
         */
        function syncGroupCheckboxes_() {
            syncGroupCheckboxesForContainer_('inspectors-container', 'chk-group-insp-');
            syncGroupCheckboxesForContainer_('lists-container', 'chk-group-list-');
        }

        function ensureFilterCheckboxCache_() {
            let inspectors = UIState.getFilterCheckboxes('inspectors');
            let lists = UIState.getFilterCheckboxes('lists');

            if (inspectors.length === 0) {
                const inspectorRoot = UIState.getDomById('inspectors-container');
                inspectors = inspectorRoot
                    ? Array.from(inspectorRoot.querySelectorAll('input[type="checkbox"][data-division][data-change-action="update-map-filters"]'))
                    : [];
                UIState.setFilterCheckboxes('inspectors', inspectors);
                inspectors = UIState.getFilterCheckboxes('inspectors');
            }

            if (lists.length === 0) {
                const listsRoot = UIState.getDomById('lists-container');
                lists = listsRoot
                    ? Array.from(listsRoot.querySelectorAll('input[type="checkbox"][data-division][data-change-action="update-map-filters"]'))
                    : [];
                UIState.setFilterCheckboxes('lists', lists);
                lists = UIState.getFilterCheckboxes('lists');
            }

            return { inspectors, lists };
        }

        /**
         * @param {string} containerId
         * @param {string} idPrefix
         */
        function syncGroupCheckboxesForContainer_(containerId, idPrefix) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const accordions = container.querySelectorAll('.accordion');
            accordions.forEach(accordion => {
                const headerCheckbox = accordion.querySelector(`input[type="checkbox"][id^="${idPrefix}"]`);
                if (!headerCheckbox) return;

                const items = accordion.querySelectorAll('.accordion-content input[type="checkbox"][data-division]');
                const total = items.length;
                let checkedCount = 0;
                items.forEach(cb => { if (cb.checked) checkedCount++; });

                if (total === 0) {
                    headerCheckbox.checked = false;
                    headerCheckbox.indeterminate = false;
                    return;
                }

                headerCheckbox.checked = checkedCount === total;
                headerCheckbox.indeterminate = checkedCount > 0 && checkedCount < total;
            });
        }

        /**
         * Массовое переключение чекбоксов в группе
         */
        function toggleDivisionFilters(division, type, isChecked) {
            const cache = ensureFilterCheckboxCache_();
            const checkboxes = (type === 'inspectors' ? cache.inspectors : cache.lists)
                .filter(cb => cb.dataset.division === division);
            checkboxes.forEach(cb => {
                cb.checked = isChecked;
            });
            
            updateMapFilters();
        }

        /**
         * Создать HTML-элемент аккордеона.
         */
        function createAccordion(title, count, checkboxId, groupMeta = null) {
            const div = document.createElement('div');
            div.className = 'accordion';
            const safeTitle = Utils.escapeHtml(title);
            const safeCheckboxId = Utils.escapeAttr(checkboxId || '');
            const safeDivision = Utils.escapeAttr((groupMeta && groupMeta.division) || '');
            const safeType = Utils.escapeAttr((groupMeta && groupMeta.type) || '');
            
            // Разметка чекбокса
            const checkboxHtml = checkboxId ? `
                <div class="checkbox-wrapper" data-stop-propagation="true" style="display:inline-flex; margin-right:8px;">
                    <input type="checkbox" id="${safeCheckboxId}" class="blue-checkbox"
                        data-change-action="toggle-division-filters"
                        data-division="${safeDivision}"
                        data-filter-type="${safeType}">
                </div>
            ` : '';

            div.innerHTML = `
                <div class="accordion-header" data-action="toggle-accordion">
                    <div class="accordion-title" style="display: flex; align-items: center;">
                        ${checkboxHtml}
                        <span>${safeTitle}</span>
                    </div>
                    <div class="accordion-meta">
                        <span class="inspector-counter">${count}</span>
                        <span class="accordion-arrow">▼</span>
                    </div>
                </div>
                <div class="accordion-content"></div>
            `;
            return div;
        }

        /**
         * Обновить фильтры карты на основе выбранных чекбоксов
         */
        function scheduleMapUpdate_() {
            if (UIState.isMapRenderQueued()) return;
            UIState.setMapRenderQueued(true);
            requestAnimationFrame(() => {
                UIState.setMapRenderQueued(false);
                updateMap();
            });
        }

        /**
         * Обновить фильтры карты на основе выбранных чекбоксов
         */
        function updateMapFilters() {
            const cache = ensureFilterCheckboxCache_();
            // Получить выбранных инспекторов
            const selectedInspectorCheckboxes = cache.inspectors.filter(cb => cb.checked);
            const selectedInspectors = selectedInspectorCheckboxes.map(cb => cb.value);
            const selectedInspectorDivisions = Array.from(
                new Set(selectedInspectorCheckboxes.map(cb => cb.dataset.division).filter(Boolean))
            );
            
            // Получить выбранные списки
            const selectedLists = cache.lists.filter(cb => cb.checked).map(cb => ({
                name: cb.value,
                division: cb.dataset.division
            }));

            const nextFilters = {
                inspectors: selectedInspectors,
                lists: selectedLists
            };

            FiltersState.setObjectsTabInspectorCache({
                inspectors: selectedInspectors,
                divisions: selectedInspectorDivisions
            });

            syncGroupCheckboxes_();
            if (areFiltersEqual_(FiltersState.getCurrent(), nextFilters)) return;

            // Обновляем фильтры приложения
            FiltersState.setCurrent(nextFilters);
            saveFiltersToStorage_(FiltersState.getCurrent());
            
            debugLog('Filters updated:', FiltersState.getCurrent());
            const managementPanel = UIState.getDomById('inspectorManagementPanel');
            if (managementPanel && !managementPanel.classList.contains('hidden') && !isInspectorRole_()) {
                renderInspectorManagement();
            }
            scheduleMapUpdate_();
        }

        /**
         * Переключить режим "Только в работе" для карты
         * @param {boolean} isChecked
         */
        function toggleOnlyActiveMode(isChecked) {
            const nextValue = !!isChecked;
            if (FiltersState.isOnlyActiveMode() === nextValue) return;
            FiltersState.setOnlyActiveMode(nextValue);
            scheduleMapUpdate_();
        }

        /**
         * Переключить показ выполненных точек на карте
         * @param {boolean} isChecked
         */
        function toggleShowCompletedOnMap(isChecked) {
            const nextValue = !!isChecked;
            if (FiltersState.isShowCompletedOnMap() === nextValue) return;
            FiltersState.setShowCompletedOnMap(nextValue);
            scheduleMapUpdate_();
        }

        /**
         * Временно оставить выполненную точку видимой на карте
         * (аналог автоскрытия в резервной копии)
         * @param {string|number} objectId
         */
        function markCompletedTemporarilyVisible_(objectId) {
            const id = String(objectId);
            FiltersState.setRecentlyCompletedUntil(id, Date.now() + COMPLETED_AUTO_HIDE_MS);

            setTimeout(() => {
                if (!FiltersState.isShowCompletedOnMap()) {
                    scheduleMapUpdate_();
                }
            }, COMPLETED_AUTO_HIDE_MS + 50);
        }

        /**
         * Сравнить фильтры и не перерисовывать карту, если изменений нет
         * @param {{inspectors:string[], lists:{name:string,division:string}[]}} a
         * @param {{inspectors:string[], lists:{name:string,division:string}[]}} b
         * @returns {boolean}
         */
        function areFiltersEqual_(a, b) {
            if (!a || !b) return false;
            if (!Array.isArray(a.inspectors) || !Array.isArray(b.inspectors)) return false;
            if (!Array.isArray(a.lists) || !Array.isArray(b.lists)) return false;
            if (a.inspectors.length !== b.inspectors.length) return false;
            if (a.lists.length !== b.lists.length) return false;

            for (let i = 0; i < a.inspectors.length; i += 1) {
                if (a.inspectors[i] !== b.inspectors[i]) return false;
            }
            for (let i = 0; i < a.lists.length; i += 1) {
                if (a.lists[i].name !== b.lists[i].name || a.lists[i].division !== b.lists[i].division) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Проверить, должна ли выполненная точка оставаться видимой временно
         * @param {string|number} objectId
         * @returns {boolean}
         */
        function isCompletedTemporarilyVisible_(objectId) {
            const id = String(objectId);
            const recentlyCompletedMap = FiltersState.getRecentlyCompletedMap();
            const until = recentlyCompletedMap.get(id);
            if (!until) return false;

            if (Date.now() > until) {
                recentlyCompletedMap.delete(id);
                return false;
            }

            return true;
        }

        /**
         * Получить выбранных инспекторов и дивизионы из блока "Списки инспекторов"
         * @returns {{inspectors: string[], divisions: string[]}}
         */
        function getSelectedInspectorFilters_() {
            const cache = FiltersState.getObjectsTabInspectorCache();
            return {
                inspectors: Array.isArray(cache.inspectors)
                    ? cache.inspectors.slice()
                    : [],
                divisions: Array.isArray(cache.divisions)
                    ? cache.divisions.slice()
                    : []
            };
        }

        /**
         * Получить отображаемое имя списка объекта.
         * Для пустых значений используем стабильный fallback.
         * @param {Object} obj
         * @returns {string}
         */
        function getObjectListName_(obj) {
            const raw = String(obj?.list ?? '')
                .replace(/\s+/g, ' ')
                .trim();
            return raw || 'Без списка';
        }

        /**
         * Ключ "дивизион::список" для фильтрации.
         * @param {Object} obj
         * @returns {string}
         */
        function getObjectListDivisionKey_(obj) {
            return `${resolveObjectDivision_(obj)}::${getObjectListName_(obj)}`;
        }

        /**
         * Определить дивизион объекта
         * @param {Object} obj
         * @returns {string}
         */
        function resolveObjectDivision_(obj) {
            if (!obj || typeof obj !== 'object') return 'Прочее';
            if (obj.__divisionResolved) return obj.__divisionResolved;
            const mappedBySheet = DIVISION_MAPPING[obj.sheetName];
            if (mappedBySheet) {
                obj.__divisionResolved = mappedBySheet;
                return mappedBySheet;
            }

            const mappedBySource = DIVISION_MAPPING[obj.source];
            if (mappedBySource) {
                obj.__divisionResolved = mappedBySource;
                return mappedBySource;
            }

            const sourceName = CONFIG.SOURCES[obj.source] || obj.source;
            if (sourceName) {
                obj.__divisionResolved = sourceName;
                return sourceName;
            }

            obj.__divisionResolved = 'Прочее';
            return obj.__divisionResolved;
        }

        /**
         * Получить объекты для вкладки "Объекты"
         * Логика: фильтрация только по выбранным инспекторам и их дивизионам
         * @returns {Object[]}
         */
        function getObjectsForObjectsTab_() {
            const objectsData = getRoleScopedObjects_(DataState.getObjectsData());
            if (!Array.isArray(objectsData) || objectsData.length === 0) return [];

            const selected = getSelectedInspectorFilters_();
            if (selected.inspectors.length === 0 || selected.divisions.length === 0) return [];

            const inspectorSet = new Set(selected.inspectors);
            const divisionSet = new Set(selected.divisions);

            return objectsData.filter(obj => {
                if (!inspectorSet.has(obj.inspector)) return false;
                const objectDivision = obj.__divisionResolved || resolveObjectDivision_(obj);
                return divisionSet.has(objectDivision);
            });
        }

        /**
         * Отложенное обновление списка при вводе в поиске вкладки "Объекты".
         */
        function scheduleObjectsListRender_() {
            if (UIState.isObjectsListRenderQueued()) return;
            UIState.setObjectsListRenderQueued(true);
            requestAnimationFrame(() => {
                UIState.setObjectsListRenderQueued(false);
                updateObjectsList();
            });
        }

        /**
         * Отложенное обновление списка при вводе в поиске вкладки "Объекты".
         */
        function scheduleObjectsListUpdate_() {
            const pendingTimer = UIState.getObjectsListUpdateTimer();
            if (pendingTimer) {
                clearTimeout(pendingTimer);
            }
            UIState.setObjectsListUpdateTimer(setTimeout(() => {
                UIState.setObjectsListUpdateTimer(null);
                scheduleObjectsListRender_();
            }, 120));
        }

        /**
         * Построить компактную сигнатуру секции, чтобы избежать лишнего ререндера.
         * @param {Object[]} items
         * @param {string} icon
         * @returns {string}
         */
        function getObjectsSectionSignature_(items, icon) {
            let hash = 2166136261;
            const update = (value) => {
                const str = String(value ?? '');
                for (let i = 0; i < str.length; i += 1) {
                    hash ^= str.charCodeAt(i);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                    hash >>>= 0;
                }
            };

            update(icon);
            update(items.length);
            for (let i = 0; i < items.length; i += 1) {
                const obj = items[i];
                update(obj?.id);
                update(obj?.entryTime);
                update(obj?.exitTime);
                update(obj?.list);
                update(obj?.address);
                update(obj?.inspector);
                update(obj?.latitude);
                update(obj?.longitude);
                update(obj?.__divisionResolved || resolveObjectDivision_(obj));
            }

            return hash.toString(16);
        }

        /**
         * Обновить бейдж секции только при изменении значения.
         * @param {'active'|'new'|'completed'} sectionKey
         * @param {string} badgeId
         * @param {number} count
         */
        function updateObjectsBadge_(sectionKey, badgeId, count) {
            if (UIState.getObjectsBadge(sectionKey) === count) return;
            UIState.setObjectsBadge(sectionKey, count);
            const badge = UIState.getDomById(badgeId);
            if (badge) badge.textContent = String(count);
        }

        /**
         * Обновить списки во вкладке "Объекты".
         */
        function updateObjectsList() {
            const activeRoot = UIState.getDomById('objectsActiveList');
            const newRoot = UIState.getDomById('objectsNewList');
            const completedRoot = UIState.getDomById('objectsCompletedList');
            if (!activeRoot || !newRoot || !completedRoot) return;

            const searchText = RuntimeState.getMapSearchQuery();

            const base = getObjectsForObjectsTab_();
            const matchesSearch = (obj) => {
                if (!searchText) return true;
                const searchBlob = obj.__searchBlobLower || `${String(obj.id || '').toLowerCase()}|${String(obj.list || '').toLowerCase()}|${String(obj.address || '').toLowerCase()}`;
                return searchBlob.includes(searchText);
            };

            const activeObjects = [];
            const newObjects = [];
            const completedObjects = [];

            for (let i = 0; i < base.length; i += 1) {
                const obj = base[i];
                if (!matchesSearch(obj)) continue;

                if (obj.entryTime && !obj.exitTime) {
                    activeObjects.push(obj);
                } else if (!obj.entryTime && !obj.exitTime) {
                    newObjects.push(obj);
                } else {
                    completedObjects.push(obj);
                }
            }

            populateObjectsList_(activeRoot, activeObjects, '🔥', 'active');
            populateObjectsList_(newRoot, newObjects, '🆕', 'new');
            populateObjectsList_(completedRoot, completedObjects, '✅', 'completed');

            updateObjectsBadge_('active', 'activeObjectsBadge', activeObjects.length);
            updateObjectsBadge_('new', 'newObjectsBadge', newObjects.length);
            updateObjectsBadge_('completed', 'completedObjectsBadge', completedObjects.length);
        }

        /**
         * Рендер списка объектов в секции вкладки "Объекты"
         * @param {HTMLElement} root
         * @param {Object[]} items
         * @param {string} icon
         * @param {'active'|'new'|'completed'} sectionKey
         */
        function populateObjectsList_(root, items, icon, sectionKey) {
            const nextSignature = getObjectsSectionSignature_(items, icon);
            if (UIState.getObjectsListRenderSignature(sectionKey) === nextSignature) return;
            UIState.setObjectsListRenderSignature(sectionKey, nextSignature);

            root.innerHTML = '';

            if (!items || items.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'objects-list-empty';
                empty.textContent = 'Нет объектов';
                root.appendChild(empty);
                return;
            }

            items.forEach(obj => {
                const row = document.createElement('div');
                row.className = 'objects-list-item';
                row.dataset.action = 'focus-object-from-list';
                row.dataset.objectId = String(obj.id);

                const iconEl = document.createElement('span');
                iconEl.textContent = icon;

                const main = document.createElement('div');
                main.className = 'objects-list-item__main';

                const title = document.createElement('div');
                title.className = 'objects-list-item__title';
                title.textContent = `#${obj.id} • ${getObjectListName_(obj)}`;

                const subAddress = document.createElement('div');
                subAddress.className = 'objects-list-item__sub';
                subAddress.textContent = obj.address || 'Без адреса';

                const subInspector = document.createElement('div');
                subInspector.className = 'objects-list-item__sub';
                subInspector.textContent = `${obj.inspector || 'Не назначен'} • ${obj.__divisionResolved || resolveObjectDivision_(obj)}`;

                const pin = document.createElement('span');
                pin.className = 'objects-list-item__sub';
                pin.textContent = '📍';

                main.appendChild(title);
                main.appendChild(subAddress);
                main.appendChild(subInspector);

                row.appendChild(iconEl);
                row.appendChild(main);
                row.appendChild(pin);

                root.appendChild(row);
            });
        }

        /**
         * Найти объект по ID и открыть его из вкладки "Объекты".
         * @param {string|number} objectId
         */
        function focusObjectFromObjectsTabById_(objectId) {
            const obj = DataState.findObjectById(objectId);
            if (!obj) return;
            focusObjectFromObjectsTab_(obj);
        }

        /**
         * Центрировать карту и открыть карточку объекта из вкладки "Объекты"
         * @param {Object} obj
         */
        function focusObjectFromObjectsTab_(obj) {
            const lat = parseFloat(obj.latitude);
            const lon = parseFloat(obj.longitude);
            const mapInstance = MapState.getMapInstance();

            if (mapInstance && !isNaN(lat) && !isNaN(lon)) {
                mapInstance.setCenter([lat, lon], 17, { duration: 250 });
            }

            openObjectDetails(obj.id);
        }

        /**
         * Обновить вкладку "Объекты" только если она активна
         */
        function refreshObjectsTabIfVisible_() {
            const pane = UIState.getDomById('nav-objects');
            if (pane && pane.classList.contains('active')) {
                scheduleObjectsListRender_();
            }
        }
        
        /**
         * Переключить вкладки нижнего меню.
         * @param {string} tabName - Идентификатор вкладки ('lists' | 'objects' | 'map' | 'exit')
         */
        function switchNav(tabName) {
            debugLog('🔘 Switched to:', tabName);
            
            if (tabName === 'exit') {
                logout();
                return;
            }
            
            // Обновить состояние кнопок меню
            document.querySelectorAll('.modern-menu-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`btn-${tabName}`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            syncMenuIndicator_(tabName);

            const objectsPane = UIState.getDomById('nav-objects');
            const objectsSearchWrapper = UIState.getDomById('objectsSearchWrapper');

            if (objectsPane) objectsPane.classList.remove('active');
            if (objectsSearchWrapper) objectsSearchWrapper.style.display = 'none';

            if (tabName === 'objects' && objectsPane) {
                objectsPane.classList.add('active');
                if (objectsSearchWrapper) objectsSearchWrapper.style.display = 'block';
                scheduleObjectsListRender_();
            }

            if (tabName === 'map' && isMobileViewport_()) {
                closeMobileSidebar_();
            } else {
                setMapInlineSearchOpen_(false);
            }
        }
        
        // ============================================
        // Модуль администрирования
        // ============================================
        
        /**
         * Показать боковую панель управления инспекторами
         */
        async function showInspectorManagement() {
            if (isInspectorRole_()) return;
            const panel = document.getElementById('inspectorManagementPanel');
            const body = document.getElementById('inspectorManagementBody');
            
            panel.classList.remove('hidden');
            
            // Если данных нет — показать загрузку и дождаться
            if (Object.keys(DataState.getInspectorsConfig()).length === 0) {
                body.innerHTML = '<div class="loading">Загрузка данных...</div>';
                
                try {
                    await loadData();
                    // Рендер произойдёт автоматически через autoRenderOpenPanels
                    // Но на всякий случай вызовем ещё раз
                    renderInspectorManagement();
                } catch (error) {
                    body.innerHTML = `
                        <div class="empty">
                            <div>❌ Ошибка загрузки</div>
                            <div style="font-size: 12px; color: #8e8e93; margin-top: 8px;">${error.message}</div>
                            <button class="apply-btn" data-action="show-inspector-management" style="margin-top: 16px;">
                                🔄 Повторить
                            </button>
                        </div>
                    `;
                }
            } else {
                renderInspectorManagement();
            }
        }
        
        /**
         * Скрыть боковую панель управления инспекторами
         * Очищает все ожидающие изменения
         */
        function closeInspectorManagement() {
            const panel = document.getElementById('inspectorManagementPanel');
            panel.classList.add('hidden');
            
            // Очистить все ожидающие изменения
            panel.querySelectorAll('.inspector-card').forEach(card => {
                delete card.dataset.changes;
            });
        }
        
        /**
         * Переключить развёрнутость карточки инспектора
         * @param {HTMLElement} card - Элемент карточки инспектора
         */
        function toggleInspectorCard(card) {
            const willOpen = !card.classList.contains('open');
            card.classList.toggle('open');
            if (willOpen) {
                warmupInspectorCardPickers_(card);
            }
        }
        
        /**
         * Фильтровать инспекторов в панели управления по тексту поиска
         * Использует значение из поля #searchManagement
         */
        function filterManagementInspectors() {
            const input = document.getElementById('searchManagement');
            const filter = String(input?.value || '').toUpperCase();
            const selectedSet = getSelectedInspectorFilterSetForManagement_();
            const cards = document.querySelectorAll('#inspectorManagementBody .inspector-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const name = String(card.querySelector('.inspector-name')?.textContent || '').toUpperCase();
                const inspectorRaw = String(card.dataset.inspector || '');
                const bySearch = !filter || name.includes(filter);
                const byInspectorFilter = isInspectorAllowedInManagementByFilters_(inspectorRaw, selectedSet);
                const isVisible = bySearch && byInspectorFilter;
                card.style.display = isVisible ? '' : 'none';
                if (isVisible) visibleCount += 1;
            });

            const emptyHint = document.getElementById('managementFilterEmpty');
            if (emptyHint) {
                emptyHint.style.display = visibleCount > 0 ? 'none' : '';
            }
        }
        
        /**
         * Отрендерить содержимое панели управления инспекторами
         * Создаёт карточки для всех инспекторов с пикерами цвета/иконки/статуса
         */
        function renderInspectorManagement() {
            const body = document.getElementById('inspectorManagementBody');
            const config = DataState.getInspectorsConfig() || {};
            const selectedSet = getSelectedInspectorFilterSetForManagement_();

            if (selectedSet.size === 0) {
                body.innerHTML = '<div class="empty">Выберите инспекторов в блоке «Списки инспекторов»</div>';
                return;
            }

            const inspectors = Object.keys(config)
                .filter(name => isInspectorAllowedInManagementByFilters_(name, selectedSet))
                .sort();
            
            if (inspectors.length === 0) {
                body.innerHTML = '<div class="empty">Нет данных об инспекторах</div>';
                return;
            }
            
            // Разделить инспекторов на активных и отсутствующих
            const active = inspectors.filter(i => normalizeInspectorManagementStatus_(config[i]?.status) === INSPECTOR_STATUS.ACTIVE);
            const inactive = inspectors.filter(i => normalizeInspectorManagementStatus_(config[i]?.status) !== INSPECTOR_STATUS.ACTIVE);
            
            let html = '<div class="inspector-list">';
            
            if (active.length > 0) {
                html += '<div class="inspector-section-title">⚡ АКТИВНЫЕ</div>';
                active.forEach((insp, idx) => html += renderInspectorCard(insp, config[insp], `a_${idx}`));
            }
            
            if (inactive.length > 0) {
                html += '<div class="inspector-section-title">⛔ ОТСУТСТВУЮТ</div>';
                inactive.forEach((insp, idx) => html += renderInspectorCard(insp, config[insp], `i_${idx}`));
            }
            
            html += '<div class="empty" id="managementFilterEmpty" style="display:none;">Нет инспекторов по текущему фильтру</div>';
            html += '</div>';
            body.innerHTML = html;
            filterManagementInspectors();
            refreshInspectorManagementWorkDayIndicators_();
        }

        /**
         * Стабильно построить уникальный id карточки инспектора.
         * Нельзя строить id только regexp-ом, т.к. для кириллицы получаются коллизии.
         * @param {string} inspectorName
         * @param {string} seed
         * @returns {string}
         */
        function buildInspectorCardId_(inspectorName, seed = '') {
            const base = String(inspectorName || '').trim();
            const raw = `${base}|${seed}`;
            let hash = 2166136261;
            for (let i = 0; i < raw.length; i += 1) {
                hash ^= raw.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                hash >>>= 0;
            }
            return `insp_${hash.toString(16)}`;
        }

        const INSPECTOR_STATUS = Object.freeze({
            ACTIVE: 'active',
            ABSENT: 'absent'
        });

        function normalizeInspectorManagementStatus_(statusRaw) {
            const statusNorm = String(statusRaw || '').trim().toLowerCase();
            return statusNorm === INSPECTOR_STATUS.ACTIVE ? INSPECTOR_STATUS.ACTIVE : INSPECTOR_STATUS.ABSENT;
        }

        function getInspectorStatusDisplay_(statusRaw) {
            const normalized = normalizeInspectorManagementStatus_(statusRaw);
            if (normalized === INSPECTOR_STATUS.ACTIVE) {
                return { value: normalized, cssClass: '', text: '🟢 Активен' };
            }
            return { value: INSPECTOR_STATUS.ABSENT, cssClass: 'absent', text: '🔴 Отсутствует' };
        }

        function getSelectedInspectorFilterSetForManagement_() {
            const selected = FiltersState.getCurrent()?.inspectors;
            if (!Array.isArray(selected) || selected.length === 0) return new Set();
            const set = new Set();
            selected.forEach(name => {
                const norm = normalizeInspectorName_(name);
                if (norm) set.add(norm);
            });
            return set;
        }

        function isInspectorAllowedInManagementByFilters_(inspectorName, selectedSet) {
            if (!(selectedSet instanceof Set)) return false;
            if (selectedSet.size === 0) return false;
            const inspectorNorm = normalizeInspectorName_(inspectorName);
            return !!inspectorNorm && selectedSet.has(inspectorNorm);
        }

        function findInspectorWorkDayPayloadByName_(map, inspectorName) {
            if (!map || typeof map !== 'object') return null;
            const key = normalizeInspectorName_(inspectorName);
            if (!key) return null;
            if (Object.prototype.hasOwnProperty.call(map, key)) return map[key];

            const keyTokens = key.split(' ').filter(Boolean);
            let bestMatchKey = '';
            let bestScore = -1;

            Object.keys(map).forEach(candidateRaw => {
                const candidate = normalizeInspectorName_(candidateRaw);
                if (!candidate) return;

                let score = -1;
                if (candidate === key) {
                    score = 1000;
                } else if (candidate.startsWith(key) || key.startsWith(candidate)) {
                    score = 500 + Math.min(candidate.length, key.length);
                } else if (keyTokens.length >= 2) {
                    const candidateTokens = candidate.split(' ').filter(Boolean);
                    if (candidateTokens.length >= 2 &&
                        candidateTokens[0] === keyTokens[0] &&
                        candidateTokens[1] === keyTokens[1]) {
                        score = 300 + Math.min(candidateTokens.length, keyTokens.length);
                    }
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestMatchKey = candidateRaw;
                }
            });

            return bestMatchKey ? map[bestMatchKey] : null;
        }

        function getInspectorWorkDayStateForManagement_(inspectorName) {
            const map = DataState.getInspectorsWorkDay();
            const payload = findInspectorWorkDayPayloadByName_(map, inspectorName);
            const isOpen = !!payload?.open;
            const openTime = String(payload?.openTime || '').trim();
            return {
                open: isOpen,
                openTime: openTime
            };
        }

        function getInspectorWorkDayBadge_(inspectorName) {
            const state = getInspectorWorkDayStateForManagement_(inspectorName);
            if (state.open) {
                const suffix = state.openTime ? ` (с ${state.openTime})` : '';
                return {
                    cssClass: 'open',
                    title: `Рабочий день открыт${suffix}`
                };
            }
            return {
                cssClass: 'closed',
                title: 'Рабочий день не открыт'
            };
        }

        function refreshInspectorManagementWorkDayIndicators_() {
            const panel = UIState.getDomById('inspectorManagementPanel');
            if (!panel || panel.classList.contains('hidden')) return;

            const cards = panel.querySelectorAll('.inspector-card');
            cards.forEach(card => {
                if (!(card instanceof HTMLElement)) return;
                const inspectorName = String(card.dataset.inspector || '');
                const badge = getInspectorWorkDayBadge_(inspectorName);
                const dot = card.querySelector('.inspector-workday-dot');
                if (!dot) return;
                dot.className = `inspector-workday-dot ${badge.cssClass}`;
                dot.setAttribute('title', badge.title);
                dot.setAttribute('aria-label', badge.title);
            });
        }
        
        /**
         * Получить данные цветов и иконок для пикеров
         * @returns {{colors: string[], icons: string[]}} Объект с массивами цветов и иконок
         */
        function getPickerData() {
            // Для цвета используем только динамическую палитру input[type=color].
            const colors = [];

            // Старые иконки убраны. Оставляем корону + список пользователя.
            const icons = [
                '👑',
                '👷‍♂️',
                '😁', '🤪', '😇',
                '🐯', '🦁', '🐸', '🐠', '🌈', '🐴', '🦅', '⭐',
                '🥋', '🏹', '🥊', '🤼‍♂️', '🤽‍♂️', '🏊‍♂️',
                '🏆', '🥇', '🤹‍♀️',
                '🏎️', '🏍️', '🛩️',
                '💎', '🚀'
            ];

            return { colors, icons };
        }

        // Компактный рендер пикеров по умолчанию.
        // Полные списки доступны через "Показать ещё" внутри каждой карточки.
        const PICKER_PREVIEW_LIMITS = Object.freeze({
            icon: 30
        });

        function buildCompactPickerItems_(allItems, selectedValue, limit) {
            const safeLimit = Math.max(1, Number(limit) || allItems.length);
            const compact = allItems.slice(0, safeLimit);
            if (!selectedValue || compact.includes(selectedValue)) return compact;

            const result = [selectedValue];
            for (let i = 0; i < compact.length && result.length < safeLimit; i++) {
                if (compact[i] !== selectedValue) result.push(compact[i]);
            }
            return result;
        }

        function renderLazyPickerOptions_(type, cardId, mode = 'compact') {
            const isColor = type === 'color';
            const isIcon = type === 'icon';
            if (!isColor && !isIcon) return;

            const card = document.getElementById('card_' + cardId);
            if (!card) return;
            const inspector = card.dataset.inspector || '';
            const cfg = DataState.ensureInspectorConfig(inspector);
            const selectedValue = String(isColor ? (cfg.color || '') : (cfg.icon || ''));

            const pickerId = (isColor ? 'colors_' : 'icons_') + cardId;
            const picker = document.getElementById(pickerId);
            if (!picker) return;

            // Цвет выбирается только через динамическую палитру (input[type=color]).
            if (isColor) {
                if (picker.dataset.mode === 'dynamic' && picker.dataset.selected === selectedValue) {
                    return;
                }
                picker.innerHTML = '';
                picker.dataset.mode = 'dynamic';
                picker.dataset.selected = selectedValue;

                const colorInput = document.querySelector(`.color-custom-input[data-card-id="${cardId}"]`);
                if (colorInput instanceof HTMLInputElement && /^#[0-9a-f]{6}$/i.test(selectedValue)) {
                    colorInput.value = selectedValue.toLowerCase();
                }

                return;
            }

            const { icons } = getPickerData();
            const allItems = icons;
            const limit = PICKER_PREVIEW_LIMITS[type] || allItems.length;
            const isFullMode = mode === 'full';
            const items = isFullMode
                ? allItems.slice()
                : buildCompactPickerItems_(allItems, selectedValue, limit);

            const nextMode = isFullMode ? 'full' : 'compact';
            if (picker.dataset.mode === nextMode && picker.dataset.selected === selectedValue) {
                return;
            }

            picker.innerHTML = items
                .map(i => `<span class="icon-option ${selectedValue === i ? 'active' : ''}" data-action="select-icon" data-card-id="${cardId}" data-icon="${i}">${i}</span>`)
                .join('');

            picker.dataset.mode = nextMode;
            picker.dataset.selected = selectedValue;

            const moreBtn = document.getElementById('icon_more_' + cardId);
            if (moreBtn) {
                moreBtn.hidden = isFullMode || allItems.length <= limit;
            }
        }

        function warmupInspectorCardPickers_(card) {
            if (!(card instanceof HTMLElement)) return;
            const cardId = String(card.id || '').replace(/^card_/, '');
            if (!cardId) return;
            renderLazyPickerOptions_('color', cardId, 'compact');
            renderLazyPickerOptions_('icon', cardId, 'compact');
        }

        function expandPickerOptions(type, cardId) {
            renderLazyPickerOptions_(type, cardId, 'full');
        }
        
        /**
         * Сгенерировать HTML для карточки инспектора
         * @param {string} insp - Имя инспектора
         * @param {Object} cfg - Конфигурация инспектора {color, icon, status}
         * @returns {string} HTML-строка
         */
        function renderInspectorCard(insp, cfg, cardIdSeed = '') {
            const cardId = buildInspectorCardId_(insp, cardIdSeed);
            const statusUi = getInspectorStatusDisplay_(cfg.status);
            const workDayBadge = getInspectorWorkDayBadge_(insp);
            const safeInspectorText = Utils.escapeHtml(String(insp || ''));
            const safeInspectorAttr = Utils.escapeAttr(String(insp || ''));
            const safeInspectorNormAttr = Utils.escapeAttr(normalizeInspectorName_(insp));
            const safeWorkDayTitle = Utils.escapeAttr(workDayBadge.title);
            
            return `
                <div class="inspector-card" data-inspector="${safeInspectorAttr}" data-inspector-norm="${safeInspectorNormAttr}" id="card_${cardId}">
                    <div class="inspector-card-header" data-action="toggle-inspector-card">
                        <span class="inspector-emoji" id="icon_${cardId}">${cfg.icon}</span>
                        <span class="inspector-name">${safeInspectorText}</span>
                        <span class="inspector-badges">
                            <span
                                class="inspector-workday-dot ${workDayBadge.cssClass}"
                                id="workday_${cardId}"
                                title="${safeWorkDayTitle}"
                                aria-label="${safeWorkDayTitle}"
                            ></span>
                        </span>
                    </div>
                    <div class="inspector-card-content">
                        <div class="control-group">
                            <label>Цвет маркера</label>
                            <div class="picker-toggle" id="color_toggle_${cardId}" data-action="toggle-picker" data-picker-type="color" data-card-id="${cardId}">
                                <div class="picker-toggle-content">
                                    <div class="picker-preview-color" id="color_preview_${cardId}" style="background:${cfg.color}"></div>
                                    <span>Выбрать цвет</span>
                                </div>
                                <span class="picker-toggle-arrow">▼</span>
                            </div>
                            <div class="picker-dropdown" id="color_dropdown_${cardId}">
                                <div class="color-custom-row">
                                    <span class="color-custom-label">Свободный цвет</span>
                                    <input
                                        type="color"
                                        class="color-custom-input"
                                        value="${cfg.color || '#1f6fb2'}"
                                        data-change-action="custom-inspector-color"
                                        data-card-id="${cardId}"
                                    >
                                </div>
                                <div class="color-picker" id="colors_${cardId}" data-mode="none" data-selected=""></div>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Иконка</label>
                            <div class="picker-toggle" id="icon_toggle_${cardId}" data-action="toggle-picker" data-picker-type="icon" data-card-id="${cardId}">
                                <div class="picker-toggle-content">
                                    <span class="picker-preview-icon" id="icon_preview_${cardId}">${cfg.icon}</span>
                                    <span>Выбрать иконку</span>
                                </div>
                                <span class="picker-toggle-arrow">▼</span>
                            </div>
                            <div class="picker-dropdown" id="icon_dropdown_${cardId}">
                                <div class="icon-picker" id="icons_${cardId}" data-mode="none" data-selected=""></div>
                                <button class="picker-more-btn" type="button" id="icon_more_${cardId}" data-action="expand-picker-options" data-picker-type="icon" data-card-id="${cardId}" hidden>Показать ещё</button>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Статус</label>
                            <div class="picker-toggle" id="status_toggle_${cardId}" data-action="toggle-picker" data-picker-type="status" data-card-id="${cardId}">
                                <div class="picker-toggle-content">
                                    <span id="status_preview_${cardId}">${statusUi.text}</span>
                                </div>
                                <span class="picker-toggle-arrow">▼</span>
                            </div>
                            <div class="picker-dropdown" id="status_dropdown_${cardId}">
                                <div class="status-options" id="status_options_${cardId}">
                                    <div class="status-option ${statusUi.value === INSPECTOR_STATUS.ACTIVE ? 'active' : ''}" data-action="select-status-option" data-card-id="${cardId}" data-status="${INSPECTOR_STATUS.ACTIVE}" data-display-text="🟢 Активен">🟢 Активен</div>
                                    <div class="status-option ${statusUi.value === INSPECTOR_STATUS.ABSENT ? 'active' : ''}" data-action="select-status-option" data-card-id="${cardId}" data-status="${INSPECTOR_STATUS.ABSENT}" data-display-text="🔴 Отсутствует">🔴 Отсутствует</div>
                                </div>
                            </div>
                        </div>
                        <button class="apply-btn" id="apply_btn_${cardId}" data-action="apply-inspector-changes" data-inspector="${safeInspectorAttr}" data-card-id="${cardId}">Сохранить</button>
                    </div>
                </div>
            `;
        }
        
        /**
         * Переключить видимость выпадающего списка
         * @param {string} type - Тип пикера ('color' | 'icon' | 'status')
         * @param {string} cardId - Идентификатор карточки
         */
        function togglePicker(type, cardId) {
            const toggle = document.getElementById(type + '_toggle_' + cardId);
            const dropdown = document.getElementById(type + '_dropdown_' + cardId);
            if (!toggle || !dropdown) return;
            
            // Закрыть остальные пикеры
            ['color', 'icon', 'status'].forEach(t => {
                if (t !== type) {
                    const otherDropdown = document.getElementById(t + '_dropdown_' + cardId);
                    const otherToggle = document.getElementById(t + '_toggle_' + cardId);
                    if (otherDropdown?.classList.contains('open')) {
                        otherDropdown.classList.remove('open');
                        otherToggle?.classList.remove('open');
                    }
                }
            });

            if (!dropdown.classList.contains('open') && (type === 'color' || type === 'icon')) {
                renderLazyPickerOptions_(type, cardId, 'compact');
            }
            
            // Переключить текущий пикер
            dropdown.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        // ============================================
        // УПРАВЛЕНИЕ ИЗМЕНЕНИЯМИ КАРТОЧЕК
        // ============================================
        
        const CardChanges = {
            /**
             * Получить элемент карточки
             * @private
             * @param {string} cardId - ID карточки
             * @returns {HTMLElement|null}
             */
            _getCard(cardId) {
                return document.getElementById('card_' + cardId);
            },
            
            /**
             * Получить изменения карточки
             * @param {string} cardId - ID карточки
             * @returns {Object} Объект изменений или пустой объект
             */
            get(cardId) {
                const card = this._getCard(cardId);
                if (!card) return {};
                try {
                    return JSON.parse(card.dataset.changes || '{}');
                } catch (e) {
                    return {};
                }
            },
            
            /**
             * Сохранить изменения карточки
             * @param {string} cardId - ID карточки
             * @param {Object} changes - Объект изменений
             */
            set(cardId, changes) {
                const card = this._getCard(cardId);
                if (card) {
                    card.dataset.changes = JSON.stringify(changes);
                }
            },
            
            /**
             * Очистить изменения карточки
             * @param {string} cardId - ID карточки
             */
            clear(cardId) {
                const card = this._getCard(cardId);
                if (card) {
                    delete card.dataset.changes;
                }
            }
        };
        
        // ============================================
        // УНИФИЦИРОВАННЫЙ ПИКЕР
        // ============================================
        
        /**
         * @typedef {Object} PickerConfig
         * @property {string} containerSuffix - Суффикс ID контейнера (например, 'colors_')
         * @property {string} itemClass - CSS-класс элементов списка (например, 'color-dot')
         * @property {string|null} dataAttr - Атрибут для хранения значения (например, 'data-color') или null
         * @property {'style'|'text'} previewType - Тип обновления превью: стиль или текст
         * @property {string} previewProp - Свойство для обновления (например, 'background' или 'textContent')
         * @property {Function|null} extraUpdate - Дополнительная функция обновления (cardId, value) => void
         * @property {boolean} [useEventTarget] - Использовать event.target для выбора (для статуса)
         */
        
        /**
         * @typedef {Object} PickerSelectOptions
         * @property {string} [displayValue] - Текст для отображения (для status)
         * @property {Event} [event] - Событие клика (для status)
         */
        
        /** @type {string} Тип пикера цвета */
        const PICKER_TYPE_COLOR = 'color';
        /** @type {string} Тип пикера иконки */
        const PICKER_TYPE_ICON = 'icon';
        /** @type {string} Тип пикера статуса */
        const PICKER_TYPE_STATUS = 'status';
        
        const Picker = {
            /**
             * Конфигурация типов пикеров
             * @type {Object.<string, PickerConfig>}
             */
            config: {
                /** @type {PickerConfig} */
                [PICKER_TYPE_COLOR]: {
                    containerSuffix: 'colors_',
                    itemClass: 'color-dot',
                    dataAttr: 'data-color',
                    previewType: 'style',
                    previewProp: 'background',
                    extraUpdate: (cardId, value) => {
                        const colorInput = document.querySelector(`.color-custom-input[data-card-id="${cardId}"]`);
                        if (colorInput instanceof HTMLInputElement && /^#[0-9a-f]{6}$/i.test(value)) {
                            colorInput.value = String(value).toLowerCase();
                        }
                        const picker = document.getElementById('colors_' + cardId);
                        const mode = picker?.dataset?.mode === 'full' ? 'full' : 'compact';
                        renderLazyPickerOptions_(PICKER_TYPE_COLOR, cardId, mode);
                    },
                    useEventTarget: false
                },
                /** @type {PickerConfig} */
                [PICKER_TYPE_ICON]: {
                    containerSuffix: 'icons_',
                    itemClass: 'icon-option',
                    dataAttr: 'data-icon',
                    previewType: 'text',
                    previewProp: 'textContent',
                    extraUpdate: (cardId, value) => {
                        const headerIcon = document.getElementById('icon_' + cardId);
                        if (headerIcon) headerIcon.textContent = value;
                    },
                    useEventTarget: false
                },
                /** @type {PickerConfig} */
                [PICKER_TYPE_STATUS]: {
                    containerSuffix: 'status_options_',
                    itemClass: 'status-option',
                    dataAttr: null,
                    previewType: 'text',
                    previewProp: 'textContent',
                    useEventTarget: true
                }
            },
            
            /**
             * Обработать выбор значения в пикере
             * @param {string} cardId - ID карточки инспектора
             * @param {string} type - Тип пикера (PICKER_TYPE_COLOR | PICKER_TYPE_ICON | PICKER_TYPE_STATUS)
             * @param {string} value - Выбранное значение
             * @param {PickerSelectOptions} [options={}] - Дополнительные опции
             */
            select(cardId, type, value, options = {}) {
                const cfg = this.config[type];
                if (!cfg) {
                    console.error('Unknown picker type:', type);
                    return;
                }
                
                // 1. Сохранить изменения
                const changes = CardChanges.get(cardId);
                changes[type] = value;
                CardChanges.set(cardId, changes);
                
                // 2. Обновить активный элемент в списке
                const container = document.getElementById(cfg.containerSuffix + cardId);
                if (container) {
                    const items = container.querySelectorAll('.' + cfg.itemClass);
                    
                    if (cfg.useEventTarget && options.event?.target) {
                        // Для статуса — через event.target
                        items.forEach(el => el.classList.remove('active'));
                        options.event.target.classList.add('active');
                    } else if (cfg.dataAttr) {
                        // Для цвета и иконки — через data-атрибут
                        items.forEach(el => {
                            const itemValue = el.getAttribute(cfg.dataAttr);
                            el.classList.toggle('active', itemValue === value);
                        });
                    }
                }
                
                // 3. Обновить превью
                const preview = document.getElementById(type + '_preview_' + cardId);
                if (preview) {
                    const displayVal = options.displayValue || value;
                    if (cfg.previewType === 'style') {
                        preview.style[cfg.previewProp] = displayVal;
                    } else {
                        preview[cfg.previewProp] = displayVal;
                    }
                }
                
                // 4. Дополнительные обновления (специфичные для типа)
                if (cfg.extraUpdate) {
                    cfg.extraUpdate(cardId, value);
                }
                
                // 5. Закрыть выпадающий список
                document.getElementById(type + '_dropdown_' + cardId)?.classList.remove('open');
                document.getElementById(type + '_toggle_' + cardId)?.classList.remove('open');
            }
        };
        
        // Обертки для обратной совместимости с inline-обработчиками
        /**
         * Обертка для выбора цвета (обратная совместимость с inline-обработчиками)
         * @param {string} cardId - ID карточки инспектора
         * @param {string} color - Выбранный цвет (hex)
         */
        function selectColor(cardId, color) {
            Picker.select(cardId, PICKER_TYPE_COLOR, color);
        }
        
        /**
         * Обертка для выбора иконки (обратная совместимость с inline-обработчиками)
         * @param {string} cardId - ID карточки инспектора
         * @param {string} icon - Выбранная иконка (эмодзи)
         */
        function selectIcon(cardId, icon) {
            Picker.select(cardId, PICKER_TYPE_ICON, icon);
        }
        
        /**
         * Обертка для выбора статуса (обратная совместимость с inline-обработчиками)
         * @param {string} cardId - ID карточки инспектора
         * @param {string} status - Значение статуса ('active' | 'absent')
         * @param {string} displayText - Текст для отображения
         * @param {Event} event - Событие клика
         */
        function selectStatusOption(cardId, status, displayText, event) {
            const normalizedStatus = normalizeInspectorManagementStatus_(status);
            const normalizedDisplay = normalizedStatus === INSPECTOR_STATUS.ACTIVE ? '🟢 Активен' : '🔴 Отсутствует';
            Picker.select(cardId, PICKER_TYPE_STATUS, normalizedStatus, {
                displayValue: displayText || normalizedDisplay,
                event
            });
        }
        
        // ============================================
        // СОХРАНЕНИЕ НАСТРОЕК ИНСПЕКТОРА
        // ============================================
        
        /**
         * Применить и сохранить изменения инспектора в Google Apps Script.
         * @param {string} inspector - Имя инспектора
         * @param {string} cardId - Идентификатор карточки
         */
        function applyInspectorChanges(inspector, cardId) {
            const changes = CardChanges.get(cardId);
            const hasStatusChange = Object.prototype.hasOwnProperty.call(changes, PICKER_TYPE_STATUS);
            
            if (Object.keys(changes).length === 0) {
                showNotification('Нет изменений для сохранения', 'info');
                return;
            }
            
            // Обновить локальную конфигурацию (с учетом возможных вариантов написания имени)
            const matchedKeys = getInspectorConfigKeysByName_(inspector);
            if (matchedKeys.length === 0) {
                Object.assign(DataState.ensureInspectorConfig(inspector), changes);
            } else {
                matchedKeys.forEach(key => {
                    Object.assign(DataState.ensureInspectorConfig(key), changes);
                });
            }
            
            // Мгновенное локальное обновление интерфейса: меняем цвет уже видимых точек инспектора
            // (без ожидания ответа сервера и без F5).
            const localStyle = getInspectorStyle(inspector);
            applyLiveInspectorColorToMap_(inspector, localStyle.color);
            refreshOpenObjectDetailsForInspector_(inspector);
            updateUserCard();
            if (UIState.isInspectorsHomesVisible()) {
                updateInspectorsHomesLayer();
            }
            
            // Состояние сохранения в интерфейсе
            const btn = document.getElementById('apply_btn_' + cardId);
            const originalText = btn.textContent;
            setButtonState(btn, 'saving');
            
            // Отправить запрос
            const request = createJsonpRequest({
                action: 'saveInspectorConfig',
                inspector,
                ...changes
            });
            
            // Обработать ответ
            request
                .then(data => {
                    if (data?.success) {
                        notifyRealtimeSync_('inspector-config');
                        CardChanges.clear(cardId);
                        setButtonState(btn, 'saved', originalText);
                        
                        if (hasStatusChange) {
                            renderInspectorManagement();
                            filterManagementInspectors();
                        }
                        
                        showNotification('Настройки сохранены', 'success');
                    } else {
                        throw new Error(data?.error || 'Ошибка сохранения');
                    }
                })
                .catch(error => {
                    setButtonState(btn, 'error', originalText);
                    showNotification(error.message, 'error');
                });
        }
        
        /**
         * Нормализовать имя инспектора для стабильного сопоставления между источниками.
         * @private
         * @param {string} value
         * @returns {string}
         */
        function normalizeInspectorName_(value) {
            return String(value || '')
                .replace(/\u00A0/g, ' ')
                .replace(/\s+/g, ' ')
                .replace(/[\u0451\u0401]/g, '\u0435')
                .trim()
                .toLowerCase();
        }
        
        /**
         * Найти все ключи конфигурации инспекторов, соответствующие отображаемому имени.
         * @private
         * @param {string} inspectorName
         * @returns {string[]}
         */
        function getInspectorConfigKeysByName_(inspectorName) {
            const inspectorsConfig = DataState.getInspectorsConfig();
            if (!inspectorsConfig || !inspectorName) return [];
            if (Object.prototype.hasOwnProperty.call(inspectorsConfig, inspectorName)) {
                return [inspectorName];
            }
            const target = normalizeInspectorName_(inspectorName);
            return Object.keys(inspectorsConfig).filter(key => normalizeInspectorName_(key) === target);
        }
        
        /**
         * Мгновенно обновить цвет у видимых на карте точек выбранного инспектора.
         * @private
         * @param {string} inspectorName
         * @param {string} color
         */
        function applyLiveInspectorColorToMap_(inspectorName, color) {
            const objectManager = MapState.getObjectManager();
            const activeLayer = MapState.getActiveObjectsLayer();
            if (!inspectorName || !color || !objectManager || !activeLayer || !Array.isArray(DataState.getObjectsData())) return;
            const target = normalizeInspectorName_(inspectorName);
            if (!target) return;
            
            const setLayerColor = (layer, objectId) => {
                if (!layer || !layer.objects || typeof layer.objects.getById !== 'function') return;
                const feature = layer.objects.getById(objectId);
                if (!feature) return;
                try {
                    layer.objects.setObjectOptions(feature.id ?? objectId, {
                        ...(feature.options || {}),
                        iconColor: color
                    });
                } catch (_) {}
            };
            
            DataState.getObjectsData().forEach(obj => {
                if (normalizeInspectorName_(obj?.inspector) !== target) return;
                setLayerColor(objectManager, obj.id);
                setLayerColor(activeLayer, obj.id);
            });
        }

        /**
         * Обновить открытые детали объекта, если объект принадлежит измененному инспектору.
         * @private
         * @param {string} inspectorName
         */
        function refreshOpenObjectDetailsForInspector_(inspectorName) {
            const openObjectId = UIState.getCurrentOpenObjectId();
            if (!inspectorName || !openObjectId) return;
            const object = DataState.findObjectById(openObjectId);
            if (!object) return;

            const updated = normalizeInspectorName_(inspectorName);
            const current = normalizeInspectorName_(object.inspector);
            if (!updated || updated !== current) return;

            const content = UIState.getDomById('objectDetailsContent');
            if (!content) return;
            renderOpenObjectDetailsContent_(object);
        }
        
        /**
         * Установить состояние кнопки
         * @param {HTMLElement} btn - Кнопка
         * @param {'saving'|'saved'|'error'} state - Состояние
         * @param {string} [originalText='Сохранить'] - Исходный текст кнопки
         */
        function setButtonState(btn, state, originalText = 'Сохранить') {
            const states = {
                saving: { text: 'Сохранение...', className: 'saving' },
                saved: { text: 'Сохранено', className: 'saved' },
                error: { text: originalText, className: '' }
            };
            
            const cfg = states[state];
            btn.textContent = cfg.text;
            btn.className = 'apply-btn ' + cfg.className;
            
            // Через 1.5 секунды вернуть исходное состояние после режима "saved"
            if (state === 'saved') {
                const resetDelay = (typeof CONFIG !== 'undefined' && CONFIG.ANIMATION?.BUTTON_RESET_DELAY) || 1500;
                setTimeout(() => setButtonState(btn, 'error', originalText), resetDelay);
            }
        }
        
        /**
         * Создать JSONP-запрос с поддержкой промиса.
         * @param {Object} params - Параметры запроса
         * @param {number} [timeout=10000] - Таймаут в мс
         * @returns {Promise} Промис с результатом
         */
        function createJsonpRequest(params, timeout = CONFIG.TIMEOUT) {
            // Проверка входных параметров
            if (!params || typeof params !== 'object') {
                return Promise.reject(new Error('Invalid params: expected object'));
            }
            
            const callbackName = 'cb_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const script = document.createElement('script');
            
            let timeoutId;
            let isResolved = false;
            
            const cleanup = () => {
                clearTimeout(timeoutId);
                if (script.parentNode) document.head.removeChild(script);
                try { delete window[callbackName]; } catch(e) {}
            };
            
            return new Promise((resolve, reject) => {
                // Обработчик таймаута
                timeoutId = setTimeout(() => {
                    isResolved = true;
                    cleanup();
                    reject(new Error('Request timeout'));
                }, timeout);
                
                // Обработчик успешного ответа
                window[callbackName] = (data) => {
                    if (isResolved) return;
                    isResolved = true;
                    cleanup();
                    
                    // Проверка валидности ответа
                    if (!data || typeof data !== 'object') {
                        reject(new Error('Invalid response format'));
                        return;
                    }

                    if (data.code === 'UNAUTHORIZED') {
                        clearStoredSession_();
                        RuntimeState.clearCurrentUser();
                        RuntimeState.clearSessionToken();
                        const overlay = document.getElementById('authOverlay');
                        if (overlay) overlay.classList.remove('hidden');
                    }
                    
                    resolve(data);
                };
                
                // Обработчик ошибок загрузки
                script.onerror = () => {
                    if (isResolved) return;
                    isResolved = true;
                    cleanup();
                    reject(new Error('Ошибка соединения'));
                };
                
                // Сформировать адрес запроса
                const requestParams = { ...params };
                const action = String(requestParams.action || '').trim();
                const sessionToken = RuntimeState.getSessionToken();
                if (action !== 'auth' && action !== 'authNonce' && requestParams.sessionToken === undefined && sessionToken) {
                    requestParams.sessionToken = sessionToken;
                }
                const queryParams = Object.entries(requestParams)
                    .map(([key, val]) => `${key}=${encodeURIComponent(val || '')}`)
                    .join('&');
                
                script.src = `${CONFIG.SCRIPT_URL}?${queryParams}&callback=${callbackName}`;
                document.head.appendChild(script);
            });
        }
        
        // ============================================
        // Модуль точек на карте (объекты)
        // ============================================
        
        /**
         * Инициализировать менеджеры объектов (ObjectManager) для точек.
         * Вызывается из initMap() после создания карты
         * @private
         */
        function initObjectManagers_() {
            // Менеджер обычных точек (Новая, Выполнена, Отказано)
            MapState.setObjectManager(new ymaps.ObjectManager({
                clusterize: false  // Кластеризацию отключаем: точки уже разнесены смещением
            }));
            
            // Менеджер активных точек (В работе), поверх обычных
            MapState.setActiveObjectsLayer(new ymaps.ObjectManager({
                clusterize: false  // Кластеризацию отключаем
            }));

            const objectManager = MapState.getObjectManager();
            const activeObjectsLayer = MapState.getActiveObjectsLayer();
            const mapInstance = MapState.getMapInstance();
            
            // Настройки балунов (хотя используем кастомный модал)
            objectManager.objects.options.set({
                balloonMaxWidth: 600,
                balloonMinWidth: 400,
                balloonPanelMaxMapArea: 0,
                openBalloonOnClick: false  // Отключаем стандартный балун по клику
            });
            
            activeObjectsLayer.objects.options.set({
                balloonMaxWidth: 600,
                balloonMinWidth: 400,
                balloonPanelMaxMapArea: 0,
                openBalloonOnClick: false  // Отключаем стандартный балун по клику
            });
            
            // Обработчики клика на точки - открываем кастомный балун
            objectManager.objects.events.add('click', (e) => {
                const objectId = e.get('objectId');
                openObjectDetails(objectId);
            });
            
            activeObjectsLayer.objects.events.add('click', (e) => {
                const objectId = e.get('objectId');
                openObjectDetails(objectId);
            });
            
            // Добавляем слои на карту
            mapInstance.geoObjects.add(objectManager);
            mapInstance.geoObjects.add(activeObjectsLayer);
            
            // Активные точки поверх обычных
            activeObjectsLayer.options.set('zIndex', 1000);
        }
        
        const COMPLETED_AUTO_HIDE_MS = 4000;

        /**
         * Обновить отображение точек на карте
         * Распределяет точки по слоям (обычные и активные) со смещением для одинаковых координат.
         */
        function clearMapLayers_() {
            MapState.clearObjectLayers();
        }

        /**
         * Построить компактную сигнатуру текущего состояния карты.
         * @param {Object[]} regularFeatures
         * @param {Object[]} activeFeatures
         * @returns {string}
         */
        function getMapRenderSignature_(regularFeatures, activeFeatures) {
            let hash = 2166136261;

            const update = (value) => {
                const str = String(value ?? '');
                for (let i = 0; i < str.length; i += 1) {
                    hash ^= str.charCodeAt(i);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                    hash >>>= 0;
                }
            };

            const visit = (feature) => {
                if (!feature) return;
                update(feature.id);
                const coords = feature.geometry?.coordinates || [];
                update(coords[0]);
                update(coords[1]);
                const opts = feature.options || {};
                update(opts.preset);
                update(opts.iconColor);
                update(opts.iconSize);
                update(feature.properties?.hintContent);
            };

            update('regular');
            update(regularFeatures.length);
            regularFeatures.forEach(visit);

            update('active');
            update(activeFeatures.length);
            activeFeatures.forEach(visit);

            return hash.toString(16);
        }

        /**
         * Применить пустое состояние карты только при фактическом изменении.
         * @param {string} stateKey
         */
        function applyEmptyMapState_(stateKey) {
            const signature = `empty:${stateKey}`;
            if (MapState.getLastRenderSignature() === signature) return;
            clearMapLayers_();
            MapState.setLastRenderSignature(signature);
        }

        /**
         * Применить наборы точек на карту только при изменении сигнатуры рендера.
         * @param {Object[]} regularFeatures
         * @param {Object[]} activeFeatures
         * @returns {boolean} true, если слои были обновлены
         */
        function applyMapRender_(regularFeatures, activeFeatures) {
            const nextSignature = getMapRenderSignature_(regularFeatures, activeFeatures);
            if (MapState.getLastRenderSignature() === nextSignature) {
                return false;
            }

            clearMapLayers_();

            const objectManager = MapState.getObjectManager();
            const activeObjectsLayer = MapState.getActiveObjectsLayer();

            if (regularFeatures.length > 0) {
                objectManager.add({
                    type: 'FeatureCollection',
                    features: regularFeatures
                });
            }
            
            if (activeFeatures.length > 0) {
                activeObjectsLayer.add({
                    type: 'FeatureCollection',
                    features: activeFeatures
                });
            }

            MapState.setLastRenderSignature(nextSignature);
            return true;
        }

        function updateMap() {
            if (!MapState.areObjectLayersReady()) {
                const retries = Number(updateMap._layerWaitRetries || 0);
                if (retries >= 30) {
                    console.warn('⚠️ ObjectManager не инициализирован (превышен лимит ожидания)');
                    return;
                }
                if (!updateMap._layerWaitTimer) {
                    updateMap._layerWaitTimer = setTimeout(() => {
                        updateMap._layerWaitTimer = null;
                        updateMap._layerWaitRetries = retries + 1;
                        scheduleMapUpdate_();
                    }, 250);
                }
                return;
            }
            updateMap._layerWaitRetries = 0;
            if (updateMap._layerWaitTimer) {
                clearTimeout(updateMap._layerWaitTimer);
                updateMap._layerWaitTimer = null;
            }

            const objectsData = getRoleScopedObjects_(DataState.getObjectsData());
            
            if (!objectsData || objectsData.length === 0) {
                debugLog('ℹ️ Нет данных для отображения на карте');
                applyEmptyMapState_('no-data');
                return;
            }
            
            debugLog('🗺️ Обновление карты:', objectsData.length, 'точек');
            
            // Сбрасываем счетчик координат
            MapState.resetCoordinateCounter();
            
            // Коллекция Map для отслеживания точек с одинаковыми координатами
            /** @type {Map<string, number>} */
            const coordinateMap = new Map();
            
            const regularFeatures = [];
            const activeFeatures = [];
            
            // Проверка, есть ли активные фильтры
            const currentFilters = FiltersState.getCurrent();
            const hasInspectorFilters = currentFilters.inspectors.length > 0;
            const hasListFilters = currentFilters.lists.length > 0;
            const hasFilters = hasInspectorFilters || hasListFilters;

            // Если фильтры не выбраны, не показываем точки (строгий режим)
            if (!hasFilters) {
                debugLog('ℹ️ Фильтры не выбраны - карта пуста');
                applyEmptyMapState_('no-filters');
                return;
            }

            // Режим "Только в работе" требует выбранных инспекторов
            if (FiltersState.isOnlyActiveMode() && !hasInspectorFilters) {
                debugLog('ℹ️ Режим "Только в работе": нет выбранных инспекторов');
                applyEmptyMapState_('active-no-inspectors');
                return;
            }

            const selectedInspectorsSet = hasInspectorFilters ? new Set(currentFilters.inspectors) : null;
            const selectedListsSet = hasListFilters
                ? new Set(currentFilters.lists.map(item => `${item.division}::${item.name}`))
                : null;
            const mapSearchQuery = RuntimeState.getMapSearchQuery();
            const hasMapSearchQuery = !!mapSearchQuery;

            // Кешируем ключи списка для текущего прохода (ускоряет фильтрацию при большом количестве точек)
            objectsData.forEach(obj => {
                if (!obj || typeof obj !== 'object') return;
                obj.__listDivisionKey = getObjectListDivisionKey_(obj);
            });

            objectsData.forEach((obj) => {
                // Фильтрация
                let match = false;
                const isActive = obj.entryTime && !obj.exitTime;
                const isCompleted = !!obj.exitTime;

                if (FiltersState.isOnlyActiveMode()) {
                    // В этом режиме используем только выбранных инспекторов и только активные точки
                    if (!isActive) return;
                    if (!selectedInspectorsSet || !selectedInspectorsSet.has(obj.inspector)) return;
                    match = true;
                } else {
                    // 1. По инспектору (логика ИЛИ)
                    if (selectedInspectorsSet && selectedInspectorsSet.has(obj.inspector)) {
                        match = true;
                    }
                    
                    // 2. По списку (логика ИЛИ)
                    // Проверяем совпадение имени списка и дивизиона (источника)
                    if (!match && selectedListsSet) {
                        const listKey = obj.__listDivisionKey || getObjectListDivisionKey_(obj);
                        if (selectedListsSet.has(listKey)) {
                            match = true;
                        }
                    }
                }
                
                if (!match) return;

                if (hasMapSearchQuery) {
                    const fallbackBlob = `${String(obj?.id || '')}|${String(obj?.list || '')}|${String(obj?.address || '')}`.toLowerCase();
                    const searchBlob = `${obj?.__searchBlobLower || fallbackBlob}|${String(obj?.inspector || '').toLowerCase()}`;
                    if (!searchBlob.includes(mapSearchQuery)) return;
                }

                // Выполненные/отказанные точки по умолчанию скрываем с карты.
                // После "Выход" точка видна ещё несколько секунд и затем исчезает.
                if (!FiltersState.isOnlyActiveMode() && isCompleted && !FiltersState.isShowCompletedOnMap() && !isCompletedTemporarilyVisible_(obj.id)) {
                    return;
                }

                const feature = createPointFeature_(obj, coordinateMap);
                if (!feature) return;
                
                if (isActive) {
                    activeFeatures.push(feature);
                } else {
                    regularFeatures.push(feature);
                }
            });
            
            // Обновляем слои только при реальном изменении набора/стиля/координат точек
            applyMapRender_(regularFeatures, activeFeatures);
            
            debugLog('✅ На карте: обычных', regularFeatures.length, ', активных', activeFeatures.length);
            refreshObjectsTabIfVisible_();
        }
        
        /**
         * Создать GeoJSON-объект точки для карты.
         * @private
         * @param {Object} obj - Данные объекта
         * @param {Map<string, number>} coordinateMap - Хранилище для отслеживания дубликатов координат
         * @returns {Object|null} GeoJSON-объект или null
         */
        function createPointFeature_(obj, coordinateMap) {
            const id = obj.id;
            const lat = parseFloat(obj.latitude);
            const lon = parseFloat(obj.longitude);
            
            if (isNaN(lat) || isNaN(lon)) {
                console.warn('⚠️ Некорректные координаты для точки', id);
                return null;
            }
            
            // Проверяем дубликаты координат и добавляем смещение
            const coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;
            const count = coordinateMap.get(coordKey) || 0;
            coordinateMap.set(coordKey, count + 1);
            
            // Смещение для точек с одинаковыми координатами (спираль)
            let offsetLat = 0;
            let offsetLon = 0;
            if (count > 0) {
                const offset = calculateOffset_(count);
                offsetLat = offset.lat;
                offsetLon = offset.lon;
            }
            
            // Определяем статус и стиль
            const isNew = !obj.entryTime && !obj.exitTime;
            const isActive = obj.entryTime && !obj.exitTime;
            const isDenied = obj.exitTime === 'нет';
            const isCompleted = !!obj.exitTime && !isDenied;
            
            const style = getInspectorStyle(obj.inspector);
            
            // Выбираем пресет и размер иконки по статусу
            let preset = 'islands#dotIcon';
            let iconColor = style.color || '#1f6fb2';
            let iconSize = CONFIG.MAP.ICON_SIZE.DEFAULT;
            
            if (isActive) {
                preset = 'islands#circleIcon';
                iconSize = CONFIG.MAP.ICON_SIZE.ACTIVE;
            } else if (isCompleted) {
                preset = 'islands#greenMedicalIcon';
                iconColor = style.color || '#1f6fb2';
            } else if (isDenied) {
                preset = 'islands#redAttentionIcon';
                iconColor = style.color || '#1f6fb2';
            }
            
            return {
                type: 'Feature',
                id: id,
                geometry: {
                    type: 'Point',
                    coordinates: [lat + offsetLat, lon + offsetLon]
                },
                properties: {
                    hintContent: getHintContent_(obj),
                    objectData: obj  // Сохраняем данные для балуна
                },
                options: {
                    preset: preset,
                    iconColor: iconColor,
                    iconSize: iconSize
                }
            };
        }
        
        /**
         * Рассчитать смещение для дубликатов координат по спирали Архимеда.
         * @private
         * @param {number} index - Индекс дубликата (1, 2, 3...)
         * @returns {{lat: number, lon: number}} Смещение в градусах
         */
        function calculateOffset_(index) {
            const { ANGLE_STEP, RADIUS_BASE } = CONFIG.MAP.SPIRAL;
            const angle = index * ANGLE_STEP;
            const radius = RADIUS_BASE * Math.sqrt(index);
            
            return {
                lat: radius * Math.cos(angle),
                lon: radius * Math.sin(angle)
            };
        }
        
        /**
         * Получить текст подсказки для точки.
         * @private
         * @param {Object} obj - Данные объекта
         * @returns {string} Текст подсказки
         */
        function getHintContent_(obj) {
            const isActive = obj.entryTime && !obj.exitTime;
            const isDenied = obj.exitTime === 'нет';
            const isCompleted = !!obj.exitTime && !isDenied;
            // Извлекаем оригинальный ID для отображения
            const displayId = obj.originalId || (obj.id.includes('_') ? obj.id.split('_')[1] : obj.id);
            
            if (isActive) return `🔵 В работе: Точка №${displayId}`;
            if (isDenied) return `🚫 Отказано: Точка №${displayId}`;
            if (isCompleted) return `✅ Выполнена: Точка №${displayId}`;
            return `🟡 Точка №${displayId}`;
        }
        
        /**
         * Получить стиль инспектора (цвет, иконка, статус)
         * @param {string} inspectorName - Имя инспектора
         * @returns {{color: string, icon: string, status: string}} Стиль инспектора
         */
        function getInspectorStyle(inspectorName) {
            const defaultStyle = { 
                color: CONFIG.DEFAULTS?.INSPECTOR_COLOR || '#1f6fb2', 
                icon: CONFIG.DEFAULTS?.INSPECTOR_ICON || '👤', 
                status: CONFIG.DEFAULTS?.INSPECTOR_STATUS || 'active' 
            };
            if (!inspectorName) {
                return defaultStyle;
            }
            const keys = getInspectorConfigKeysByName_(inspectorName);
            if (keys.length === 0) return defaultStyle;
            
            const resolved = DataState.getInspectorsConfig()[keys[0]] || {};
            const resolvedStatus = normalizeInspectorManagementStatus_(resolved.status);
            return {
                ...defaultStyle,
                ...resolved,
                status: resolvedStatus
            };
        }
        
        // ============================================
        // Модуль балуна (кастомный модал)
        // ============================================
        
        /**
         * Открыть детали объекта в кастомном модальном окне
         * @param {string|number} objectId - ID объекта
         */
        function openObjectDetails(objectId) {
            const object = DataState.findObjectById(objectId);
            if (!object) {
                console.error('❌ Объект не найден:', objectId);
                return;
            }
            
            UIState.setCurrentOpenObjectId(objectId);
            const content = UIState.getDomById('objectDetailsContent');
            if (!content) return;
            
            renderOpenObjectDetailsContent_(object);
            
            const overlay = UIState.getDomById('objectDetailsOverlay');
            if (!overlay) return;
            overlay.classList.add('object-details--visible');
            overlay.classList.remove('hidden');
            document.body.classList.add('object-details-open');
            
            // Инициализировать кнопки Яндекс.Диска
            setTimeout(() => {
                initYandexDiskButtons();
            }, 100);
        }
        
        /**
         * Закрыть модальное окно деталей объекта
         */
        function closeObjectDetails() {
            UIState.clearCurrentOpenObjectId();
            const overlay = UIState.getDomById('objectDetailsOverlay');
            if (!overlay) return;
            overlay.classList.remove('object-details--visible');
            overlay.classList.add('hidden');
            document.body.classList.remove('object-details-open');
        }
        
        /**
         * Получить конфигурацию статуса объекта.
         * @param {Object} obj - Данные объекта
         * @returns {{isNew: boolean, isActive: boolean, isDenied: boolean, isCompleted: boolean}}
         */
        function getObjectStatus(obj) {
            const isNew = !obj.entryTime && !obj.exitTime;
            const isActive = obj.entryTime && !obj.exitTime;
            const isDenied = obj.exitTime === 'нет';
            const isCompleted = !!obj.exitTime && !isDenied;
            return { isNew, isActive, isDenied, isCompleted };
        }

        function renderActionLabel_(emoji, text) {
            const safeEmoji = String(emoji || '').trim();
            const safeText = Utils.escapeHtml(String(text || ''));
            const emojiHtml = safeEmoji
                ? `<span class="object-card__button-emoji" aria-hidden="true">${Utils.escapeHtml(safeEmoji)}</span>`
                : '';
            return `${emojiHtml}<span class="object-card__button-text">${safeText}</span>`;
        }
        
        /**
         * Сформировать кнопки действий по текущему статусу объекта.
         * @param {Object} obj - Данные объекта
         * @param {Object} status - Объект статуса
         * @returns {string} HTML-строка
         */
        function renderActionButtons(obj, { isNew, isActive }) {
            const objectIdAttr = Utils.escapeAttr(obj.id);
            if (isNew) {
                return `<div class="object-card__actions" style="margin-top: 12px;">
                    <button class="object-card__button" data-action="mark-entry" data-object-id="${objectIdAttr}">${renderActionLabel_('➡️', 'Вход')}</button>
                </div>`;
            }
            if (isActive) {
                const allowCancelEntry = !isInspectorRole_();
                return `<div class="object-card__actions" style="margin-top: 12px;">
                    <button class="object-card__button" data-action="mark-exit" data-object-id="${objectIdAttr}">${renderActionLabel_('🏁', 'Выход')}</button>
                    ${allowCancelEntry ? `<button class="object-card__button" data-action="cancel-entry" data-object-id="${objectIdAttr}">${renderActionLabel_('↩️', 'Отменить вход')}</button>` : ''}
                    <button class="object-card__button" data-action="mark-denied" data-object-id="${objectIdAttr}">${renderActionLabel_('🚫', 'Отказано')}</button>
                    <button class="object-card__button" data-action="call-laboratory" data-object-id="${objectIdAttr}">${renderActionLabel_('🔬', 'Лаборатория')}</button>
                </div>`;
            }
            return '';
        }
        
        /**
         * Сформировать селект переназначения инспектора.
         * @param {Object} obj - Данные объекта
         * @returns {string} HTML-строка
         */
        function renderReassignSelect(obj) {
            if (isInspectorRole_()) return '';

            const options = Object.keys(DataState.getInspectorsConfig()).sort().map(insp => {
                const style = getInspectorStyle(insp);
                const selected = obj.inspector === insp ? 'selected' : '';
                const valueAttr = Utils.escapeAttr(insp);
                const optionText = Utils.escapeHtml(`${style.icon} ${insp}`);
                return `<option value="${valueAttr}" ${selected}>${optionText}</option>`;
            }).join('');
            const objectIdAttr = Utils.escapeAttr(obj.id);
            
            return `<div class="object-card__section--reassign">
                <div class="object-card__label">Переназначить инспектора</div>
                <select class="object-card__select" data-change-action="reassign-inspector" data-object-id="${objectIdAttr}">
                    <option value="">-- Выберите инспектора --</option>
                    ${options}
                </select>
            </div>`;
        }
        
        /**
         * Сформировать кнопку Яндекс.Диска.
         * @param {Object} obj - Данные объекта
         * @param {boolean} isActive - Активен ли объект
         * @returns {string} HTML-строка
         */
        function getPhotoReportLink_(obj) {
            return String(obj?.photosLink || '').trim();
        }

        function getYandexWorkLink_(obj) {
            return String(obj?.yandexDiskLink || obj?.photosLink || '').trim();
        }

        function buildYandexDiskClientLink_(pathRaw) {
            const path = String(pathRaw || '').trim().replace(/^\/+|\/+$/g, '');
            if (!path) return '';
            const encodedPath = path
                .split('/')
                .filter(Boolean)
                .map(part => encodeURIComponent(part))
                .join('/');
            return `https://disk.yandex.ru/client/disk/${encodedPath}`;
        }

        function renderYandexButton(obj, isActive) {
            const reportLink = getPhotoReportLink_(obj);
            const yandexWorkLink = getYandexWorkLink_(obj);
            const objectIdAttr = Utils.escapeAttr(obj.id);
            const safeReportLink = Utils.sanitizeUrl(reportLink);
            if (isActive) {
                if (safeReportLink) {
                    return `<button class="object-card__button" data-action="yandex-disk" data-yandex-mode="open" data-yandex-object="${objectIdAttr}" data-yandex-target="${Utils.escapeAttr(safeReportLink)}" data-yandex-report-link="${Utils.escapeAttr(safeReportLink)}">${renderActionLabel_('🖼️', 'Просмотр фотоотчета')}</button>`;
                }
                if (!yandexWorkLink) return '';
                return `<button class="object-card__button" data-action="yandex-disk" data-yandex-mode="create" data-yandex-object="${objectIdAttr}" data-yandex-link="${Utils.escapeAttr(yandexWorkLink)}" data-yandex-report-link="${Utils.escapeAttr(reportLink)}">${renderActionLabel_('✨', 'Создать папки')}</button>`;
            }
            const safeUrl = Utils.sanitizeUrl(reportLink || yandexWorkLink);
            if (!safeUrl) return '';
            return `<a href="${Utils.escapeAttr(safeUrl)}" target="_blank" rel="noopener noreferrer" class="object-card__button">${renderActionLabel_('🖼️', 'Просмотр фотоотчета')}</a>`;
        }

        function getRenderSig_(value) {
            const input = String(value ?? '');
            let hash = 2166136261;
            for (let i = 0; i < input.length; i += 1) {
                hash ^= input.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                hash >>>= 0;
            }
            return hash.toString(16);
        }

        function buildObjectCardViewModel_(obj, icon) {
            const status = getObjectStatus(obj);

            return {
                status,
                objectIdRaw: String(obj.id || ''),
                objectIdAttr: Utils.escapeAttr(obj.id),
                coordinates: Utils.escapeAttr(`${obj.latitude}, ${obj.longitude}`),
                inspectorDisplay: Utils.escapeHtml(obj.inspector || 'Не назначен'),
                sourceLabel: Utils.escapeHtml(CONFIG.SOURCES[obj.source] || obj.source || ''),
                displayId: Utils.escapeHtml(Utils.extractDisplayId(obj.originalId || obj.id)),
                iconSafe: Utils.escapeHtml(icon || '📍'),
                listLabel: Utils.escapeHtml(obj.list || 'Без списка'),
                addressLabel: Utils.escapeHtml(obj.address || '—'),
                entryLabel: Utils.escapeHtml(Utils.formatDate(obj.entryTime)),
                exitLabel: Utils.escapeHtml(Utils.formatDate(obj.exitTime)),
                laboratoryComment: Utils.escapeHtml(obj.laboratoryComment || ''),
                googleLink: Utils.sanitizeUrl(obj.googleLink || '')
            };
        }

        function renderObjectCardHeaderHtml_(vm) {
            return `
                <div class="object-card__title">
                    <span class="object-card__emoji">${vm.iconSafe}</span>
                    <div>
                        <div class="object-card__name">${vm.sourceLabel}<br>Точка №${vm.displayId}</div>
                        <div class="object-card__meta">${vm.listLabel}</div>
                    </div>
                </div>
            `;
        }

        function renderObjectCardInfoHtml_(obj, vm) {
            return `
                <div class="object-card__row">
                    <span class="object-card__label">Адрес</span>
                    <span class="object-card__value">${vm.addressLabel}</span>
                </div>
                <div class="object-card__row">
                    <span class="object-card__label">Инспектор</span>
                    <span class="object-card__value">${vm.inspectorDisplay}</span>
                </div>
                ${obj.entryTime ? `
                <div class="object-card__row">
                    <span class="object-card__label">Вход</span>
                    <span class="object-card__value">${vm.entryLabel}</span>
                </div>
                ` : ''}
                ${obj.exitTime && obj.exitTime !== 'нет' ? `
                <div class="object-card__row">
                    <span class="object-card__label">Выход</span>
                    <span class="object-card__value">${vm.exitLabel}</span>
                </div>
                ` : ''}
                ${obj.exitTime === 'нет' ? `
                <div class="object-card__row">
                    <span class="object-card__label">Статус</span>
                    <span class="object-card__value" style="color: #e74c3c;">Отказано</span>
                </div>
                ` : ''}
                ${obj.laboratory ? `
                <div class="object-card__row">
                    <span class="object-card__label">Лаборатория</span>
                    <span class="object-card__value">${vm.laboratoryComment}</span>
                </div>
                ` : ''}
            `;
        }

        function renderObjectCardPrimaryActionsHtml_(obj, vm) {
            return `
                ${vm.googleLink ? `<a href="${Utils.escapeAttr(vm.googleLink)}" target="_blank" rel="noopener noreferrer" class="object-card__button">${renderActionLabel_('📝', 'Чек-лист')}</a>` : ''}
                ${renderYandexButton(obj, vm.status.isActive)}
                <button class="object-card__button" data-action="copy-coordinates" data-coordinates="${vm.coordinates}">${renderActionLabel_('🧭', 'Координаты')}</button>
            `;
        }

        function buildObjectCardSections_(obj, icon) {
            const vm = buildObjectCardViewModel_(obj, icon);
            return {
                objectIdRaw: vm.objectIdRaw,
                objectIdAttr: vm.objectIdAttr,
                headerHtml: renderObjectCardHeaderHtml_(vm),
                infoHtml: renderObjectCardInfoHtml_(obj, vm),
                primaryActionsHtml: renderObjectCardPrimaryActionsHtml_(obj, vm),
                secondaryActionsHtml: renderActionButtons(obj, vm.status),
                reassignHtml: renderReassignSelect(obj)
            };
        }

        function patchCardSectionHtml_(card, selector, nextHtml) {
            const target = card.querySelector(selector);
            if (!target) return false;
            const nextSig = getRenderSig_(nextHtml);
            if (target.dataset.renderSig === nextSig) return false;
            target.innerHTML = nextHtml;
            target.dataset.renderSig = nextSig;
            return true;
        }

        function patchOpenObjectDetailsContent_(obj) {
            const content = UIState.getDomById('objectDetailsContent');
            if (!content || !obj) return false;

            const card = content.querySelector('.object-card');
            if (!card) return false;
            if (String(card.dataset.objectId || '') !== String(obj.id || '')) return false;

            const style = getInspectorStyle(obj.inspector);
            const sections = buildObjectCardSections_(obj, style.icon);

            patchCardSectionHtml_(card, '.js-object-card-header', sections.headerHtml);
            patchCardSectionHtml_(card, '.js-object-card-info', sections.infoHtml);
            patchCardSectionHtml_(card, '.js-object-card-primary-actions', sections.primaryActionsHtml);
            patchCardSectionHtml_(card, '.js-object-card-secondary-actions', sections.secondaryActionsHtml);
            patchCardSectionHtml_(card, '.js-object-card-reassign', sections.reassignHtml);

            card.dataset.objectId = sections.objectIdRaw;
            return true;
        }

        function renderOpenObjectDetailsContent_(obj) {
            const content = UIState.getDomById('objectDetailsContent');
            if (!content || !obj) return;
            if (patchOpenObjectDetailsContent_(obj)) return;

            const style = getInspectorStyle(obj.inspector);
            content.innerHTML = getBalloonContent(obj, style.icon);
        }
        
        /**
         * Сгенерировать HTML-контент для балуна объекта.
         * @param {Object} obj - Данные объекта
         * @param {string} icon - Иконка инспектора
         * @returns {string} HTML строка
         */
        function getBalloonContent(obj, icon) {
            const sections = buildObjectCardSections_(obj, icon);
            
            // Используем renderYandexButton для генерации кнопки Яндекс.Диска
            
            return `
                <div class="object-card" data-object-id="${sections.objectIdAttr}">
                    <div class="object-card__header js-object-card-header" data-render-sig="${getRenderSig_(sections.headerHtml)}">
                        ${sections.headerHtml}
                    </div>
                    
                    <div class="object-card__info js-object-card-info" data-render-sig="${getRenderSig_(sections.infoHtml)}">
                        ${sections.infoHtml}
                    </div>
                    
                    <div class="object-card__actions js-object-card-primary-actions" data-render-sig="${getRenderSig_(sections.primaryActionsHtml)}">
                        ${sections.primaryActionsHtml}
                    </div>
                    
                    <div class="js-object-card-secondary-actions" data-render-sig="${getRenderSig_(sections.secondaryActionsHtml)}">${sections.secondaryActionsHtml}</div>
                    <div class="js-object-card-reassign" data-render-sig="${getRenderSig_(sections.reassignHtml)}">${sections.reassignHtml}</div>
                    <div class="object-card__spacer"></div>
                </div>
            `;
        }
        
        // Примечание: используем Utils.formatDate() вместо formatDate_()
        
        // ============================================
        // ДЕЙСТВИЯ С ТОЧКАМИ
        // ============================================
        
        /**
         * Отметить вход на объект
         * @param {string|number} objectId - ID объекта
         */
        function markEntry(objectId) {
            executeObjectAction_(objectId, 'entry', {});
        }
        
        /**
         * Отметить выход с объекта
         * @param {string|number} objectId - ID объекта
         */
        function markExit(objectId) {
            executeObjectAction_(objectId, 'exit', {});
        }
        
        /**
         * Отменить вход (очистить entryTime)
         * Показывает диалог подтверждения
         * @param {string|number} objectId - ID объекта
         */
        function cancelEntry(objectId) {
            if (!confirm('Отменить вход? Точка вернётся в статус "Новая".')) return;
            executeObjectAction_(objectId, 'cancelEntry', {});
        }
        
        /**
         * Отметить объект как "Отказано"
         * Показывает диалог подтверждения
         * @param {string|number} objectId - ID объекта
         */
        function markDenied(objectId) {
            if (!confirm('Отметить точку как "Отказано"?')) return;
            executeObjectAction_(objectId, 'denyAccess', {});
        }
        
        /**
         * Вызвать лабораторию
         * Показывает окно ввода комментария.
         * @param {string|number} objectId - ID объекта
         */
        function callLaboratory(objectId) {
            const comment = prompt('Комментарий для лаборатории:');
            if (comment === null) return; // Отмена
            
            executeObjectAction_(objectId, 'callLaboratory', { comment: comment });
        }
        
        /**
         * Переназначить инспектора объекта
         * @param {string|number} objectId - ID объекта
         * @param {string} newInspector - Имя нового инспектора
         */
        function reassignInspector(objectId, newInspector) {
            if (!newInspector) return;
            const object = DataState.findObjectById(objectId);
            if (object && object.inspector === newInspector) return;
            executeObjectAction_(objectId, 'reassign', { newInspector: newInspector });
        }
        
        /**
         * Скопировать координаты в буфер обмена
         * @param {string} coordinates - Координаты "lat, lon"
         */
        async function copyCoordinates(coordinates) {
            const success = await Utils.copyToClipboard(coordinates);
            showNotification(success ? '🧭 Координаты скопированы' : 'Не удалось скопировать координаты', success ? 'success' : 'error');
        }

        async function archiveCompletedObjects() {
            const confirmed = confirm('Архивировать выполненные объекты? Они будут перенесены в лист Archive и удалены из рабочих листов.');
            if (!confirmed) return;

            showNotification('⏳ Начинаю архивацию...', 'info');

            try {
                const response = await createJsonpRequest({ action: 'archiveCompleted' }, 60000);
                if (!response?.success) {
                    showNotification('❌ ' + (response?.message || response?.error || 'Ошибка архивации'), 'error');
                    return;
                }

                const count = Number(response?.count || 0);
                if (count <= 0) {
                    showNotification('ℹ️ Нет выполненных объектов для архивации', 'info');
                    return;
                }

                const details = response?.bySource && typeof response.bySource === 'object'
                    ? Object.entries(response.bySource)
                        .map(([name, value]) => `${name}: ${Number(value || 0)}`)
                        .join(', ')
                    : '';

                showNotification(
                    `✅ Архивация завершена. Перенесено: ${count}${details ? ` (${details})` : ''}`,
                    'success'
                );

                notifyRealtimeSync_('archive-completed');
                await loadDataWithRetry_({ attempts: 2, retryDelayMs: 600, reason: 'archive-completed' });
            } catch (error) {
                showNotification('❌ ' + (error?.message || 'Ошибка архивации'), 'error');
            }
        }

        const YANDEX_FOLDER_CREATION_IN_PROGRESS = new Set();
        
        // ==================================================================
        // Работа с папками на Яндекс.Диске
        // ==================================================================
        
        /**
         * Создать папку на Яндекс.Диске через API.
         * @param {string} path - Путь к папке
         * @returns {Promise<{success: boolean, created: boolean, code: number, message?: string}>}
         */
        async function createYandexFolder(path) {
            try {
                const response = await createJsonpRequest({
                    action: 'yandexCreateFolder',
                    path: String(path || '')
                }, 30000);
                const code = Number(response?.code || 0);
                if (response?.success && (code === 201 || code === 409)) {
                    return { success: true, code: code, created: !!response.created };
                }
                return {
                    success: false,
                    code: code,
                    message: response?.message || response?.error || 'Yandex API error'
                };
            } catch (error) {
                return { success: false, code: 0, message: error.message };
            }
        }
        
        /**
         * Проверка существования папки на Яндекс.Диске
         * @param {string} path - Путь к папке
         * @returns {Promise<boolean>}
         */
        async function checkYandexFolder(path) {
            try {
                const response = await createJsonpRequest({
                    action: 'yandexCheckFolder',
                    path: String(path || '')
                }, 30000);
                return !!(response?.success && response?.exists);
            } catch (error) {
                console.warn('Ошибка проверки папки:', error);
                return false;
            }
        }
        
        /**
         * Обработчик создания папок на Яндекс.Диске
         * @param {string} objectId - ID объекта
         * @param {string} yandexLink - Ссылка на папку из таблицы
         */
        async function savePhotosLinkToSheet_(objectId, photosLink) {
            if (!objectId || !photosLink) return { success: false, error: 'invalid params' };

            const object = DataState.findObjectById(objectId);
            if (!object) return { success: false, error: 'object not found' };

            try {
                const response = await createJsonpRequest({
                    action: 'savePhotosLink',
                    objectId: String(objectId),
                    source: object.source || 'Map',
                    photosLink: photosLink
                }, 15000);

                if (response?.success) {
                    object.photosLink = photosLink;
                    notifyRealtimeSync_('photos-link');
                    return { success: true };
                }
                return { success: false, error: response?.error || 'save failed' };
            } catch (error) {
                return { success: false, error: error?.message || 'request failed' };
            }
        }

        async function handleYandexDiskButton(objectId, yandexLink, reportLink = '') {
            if (!objectId || !yandexLink) {
                console.error('❌ Не передан objectId или yandexLink');
                alert('Ошибка: не указана ссылка на Яндекс.Диск');
                return;
            }
            const objectKey = String(objectId);
            if (YANDEX_FOLDER_CREATION_IN_PROGRESS.has(objectKey)) {
                return;
            }
            
            const btn = document.querySelector(`[data-yandex-object="${objectId}"]`);
            if (!btn) {
                console.error('❌ Кнопка Яндекс.Диск не найдена');
                return;
            }

            YANDEX_FOLDER_CREATION_IN_PROGRESS.add(objectKey);
            
            // Блокируем кнопку и показываем спиннер
            btn.dataset.yandexBusy = '1';
            btn.disabled = true;
            btn.style.opacity = '0.6';
            btn.innerHTML = `<div style="display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%;">
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span class="yandex-spinner"></span>
                    <span>Создание папок...</span>
                </div>
                <div class="yandex-progress-container" style="width: calc(100% - 20px);">
                    <div class="yandex-progress-bar" id="yandex-progress-${objectId}" style="width: 0%;"></div>
                </div>
            </div>`;
            
            try {
                // Формируем имя основной папки
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                const dateStr = `${dd}.${mm}.${yyyy}`;
                const inspectorName = RuntimeState.getCurrentUserName('Инспектор');
                const mainFolderName = `${dateStr} ${inspectorName}`;
                

                
                // Извлекаем путь из ссылки
                let folderPath = '';
                if (yandexLink.includes('/client/disk/')) {
                    const pathPart = yandexLink.split('/client/disk/')[1];
                    folderPath = decodeURIComponent(pathPart.split('?')[0]);
                } else {
                    folderPath = `${CONFIG.YANDEX.ROOT_PATH}/${objectId}`;
                }
                
                const mainPath = `${folderPath}/${mainFolderName}`;
                debugLog('🔥 MainPath:', mainPath);
                
                const progressBar = document.getElementById('yandex-progress-' + objectId);
                
                // Создаём основную папку
                const mainResult = await createYandexFolder(mainPath);
                if (!mainResult.success && mainResult.code !== 409) {
                    throw new Error(`Ошибка создания папки: ${mainResult.message}`);
                }
                const initialProgress = CONFIG.PROGRESS?.INITIAL_PERCENT || 20;
                if (progressBar) progressBar.style.width = `${initialProgress}%`;
                
                // Получить список подпапок из конфигурации
                const subfolders = CONFIG.YANDEX.SUBFOLDERS;
                
                // Создаём подпапки параллельно
                let created = 0;
                const progressStep = 80 / subfolders.length;
                
                const folderPromises = subfolders.map(async (subfolder) => {
                    const subPath = `${mainPath}/${subfolder}`;
                    debugLog('🔥 Создание подпапки:', subPath);
                    
                    try {
                        const result = await createYandexFolder(subPath);
                        if (progressBar) {
                            const currentWidth = parseFloat(progressBar.style.width) || (CONFIG.PROGRESS?.INITIAL_PERCENT || 20);
                            progressBar.style.width = Math.min(currentWidth + progressStep, 100) + '%';
                        }
                        
                        if (result.success || result.code === 409) {
                            if (result.created) created++;
                            return { success: true, subfolder };
                        } else {
                            console.warn(`⚠️ Ошибка создания подпапки "${subfolder}":`, result);
                            return { success: false, subfolder };
                        }
                    } catch (error) {
                        console.warn(`⚠️ Исключение при создании подпапки "${subfolder}":`, error);
                        return { success: false, subfolder };
                    }
                });
                
                await Promise.all(folderPromises);
                
                const completeProgress = CONFIG.PROGRESS?.COMPLETE_PERCENT || 100;
                if (progressBar) progressBar.style.width = `${completeProgress}%`;
                
                // Формируем прямую ссылку на созданную папку
                const directLink = buildYandexDiskClientLink_(mainPath);
                
                // Обновляем кнопку
                btn.innerHTML = renderActionLabel_('🖼️', 'Просмотр фотоотчета');
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.dataset.yandexMode = 'open';
                btn.dataset.yandexTarget = directLink;
                btn.dataset.yandexReportLink = directLink;
                
                const saveResult = await savePhotosLinkToSheet_(objectId, directLink);
                if (!saveResult.success) {
                    console.warn('Не удалось сохранить Photos_link:', saveResult.error || 'unknown error');
                }
                
                showNotification(
                    `✅ Папки созданы!\n\nСоздано: ${mainFolderName}\nПодпапок: ${created}/${subfolders.length}`,
                    'success'
                );
                
            } catch (error) {
                console.error('❌ Ошибка создания папок:', error);
                btn.innerHTML = renderActionLabel_('✨', 'Создать папки');
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.dataset.yandexMode = 'create';
                delete btn.dataset.yandexTarget;
                alert('❌ Не удалось создать папки:\n\n' + (error.message || 'Неизвестная ошибка'));
            } finally {
                YANDEX_FOLDER_CREATION_IN_PROGRESS.delete(objectKey);
                delete btn.dataset.yandexBusy;
            }
        }

        /**
         * Унифицированный обработчик клика по кнопке Яндекс.Диска.
         * Работает через делегирование data-action, без прямых onclick.
         * @param {HTMLElement} actionNode
         */
        function handleYandexDiskAction_(actionNode) {
            const mode = actionNode.dataset.yandexMode || 'create';
            if (mode === 'open') {
                const directLink = actionNode.dataset.yandexTarget
                    || actionNode.dataset.yandexReportLink
                    || actionNode.dataset.yandexLink
                    || '';
                const safeUrl = Utils.sanitizeUrl(directLink);
                if (safeUrl) window.open(safeUrl, '_blank');
                return;
            }

            const objectId = actionNode.dataset.yandexObject || '';
            const yandexLink = actionNode.dataset.yandexLink || '';
            const reportLink = actionNode.dataset.yandexReportLink || yandexLink;
            if (!objectId || !yandexLink) return;
            handleYandexDiskButton(objectId, yandexLink, reportLink);
        }
        
        /**
         * Инициализация кнопок Яндекс.Диск после открытия балуна
         */
        async function initYandexDiskButtons() {
            const buttons = document.querySelectorAll('[data-yandex-object]');
            
            for (const btn of buttons) {
                const objectId = btn.getAttribute('data-yandex-object');
                const yandexLink = btn.getAttribute('data-yandex-link');
                const reportLink = btn.getAttribute('data-yandex-report-link') || yandexLink;
                
                if (!objectId || !yandexLink) continue;
                if (btn.dataset.yandexBusy === '1' || YANDEX_FOLDER_CREATION_IN_PROGRESS.has(String(objectId))) continue;
                if ((btn.dataset.yandexMode || '') === 'open' && (btn.dataset.yandexTarget || '')) continue;
                
                // Находим объект в данных
                const object = DataState.findObjectById(objectId);
                const isActive = object?.entryTime && !object?.exitTime;
                const directFromSheet = Utils.sanitizeUrl(String(object?.photosLink || '').trim());
                
                // Если вход не выполнен - просто открываем ссылку
                if (!isActive) {
                    btn.innerHTML = renderActionLabel_('🖼️', 'Просмотр фотоотчета');
                    btn.dataset.yandexMode = 'open';
                    btn.dataset.yandexTarget = directFromSheet || reportLink;
                    continue;
                }

                // Если ссылка на фотоотчет уже сохранена в таблице — приоритетно открываем её.
                if (directFromSheet) {
                    btn.innerHTML = renderActionLabel_('🖼️', 'Просмотр фотоотчета');
                    btn.dataset.yandexMode = 'open';
                    btn.dataset.yandexTarget = directFromSheet;
                    btn.dataset.yandexReportLink = directFromSheet;
                    continue;
                }
                
                // Проверяем существование папки
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                const dateStr = `${dd}.${mm}.${yyyy}`;
                const inspectorName = RuntimeState.getCurrentUserName('Инспектор');
                const mainFolderName = `${dateStr} ${inspectorName}`;
                
                let folderPath = '';
                if (yandexLink.includes('/client/disk/')) {
                    const pathPart = yandexLink.split('/client/disk/')[1];
                    folderPath = decodeURIComponent(pathPart.split('?')[0]);
                } else {
                    folderPath = `${CONFIG.YANDEX.ROOT_PATH}/${objectId}`;
                }
                
                const folderPathToCheck = `${folderPath}/${mainFolderName}`;
                const folderExists = await checkYandexFolder(folderPathToCheck);
                if (btn.dataset.yandexBusy === '1' || YANDEX_FOLDER_CREATION_IN_PROGRESS.has(String(objectId))) continue;
                
                if (folderExists) {
                    const directLink = buildYandexDiskClientLink_(folderPathToCheck);
                    btn.innerHTML = renderActionLabel_('🖼️', 'Просмотр фотоотчета');
                    btn.dataset.yandexMode = 'open';
                    btn.dataset.yandexTarget = directLink;
                    btn.dataset.yandexReportLink = directLink;
                } else {
                    btn.innerHTML = renderActionLabel_('✨', 'Создать папки');
                    btn.dataset.yandexMode = 'create';
                    delete btn.dataset.yandexTarget;
                }
            }
        }
        
        /**
         * Выполнить действие с объектом через JSONP.
         * @private
         * @param {string|number} objectId - ID объекта
         * @param {string} action - Тип действия
         * @param {Object} params - Дополнительные параметры
         */
        function executeObjectAction_(objectId, action, params) {
            // Проверить входные параметры
            if (!objectId) {
                showNotification('❌ Ошибка: не указан ID объекта', 'error');
                return;
            }
            
            if (!action || typeof action !== 'string') {
                showNotification('❌ Ошибка: не указано действие', 'error');
                return;
            }
            
            // Оптимистичное обновление интерфейса
            const object = DataState.findObjectById(objectId);
            if (object) {
                optimisticallyUpdateObject_(objectId, action, params);
            }
            
            // Закрыть модальное окно деталей
            closeObjectDetails();
            
            // Сформировать параметры запроса
            const requestParams = {
                action: action,
                objectId: String(objectId),
                source: object?.source || 'Map',
                ...params
            };
            
            // Отправляем запрос
            createJsonpRequest(requestParams, 15000)
                .then(response => {
                    if (response.success) {
                        notifyRealtimeSync_(`object:${action}`);
                        showNotification('✅ ' + (response.message || 'Действие выполнено'), 'success');
                        // Для переназначения оставляем локальный мгновенный UI и
                        // не перетираем его immediate-перезагрузкой данных.
                        if (action === 'reassign') {
                            return;
                        } else {
                            // Перезагружаем данные для синхронизации
                            reloadData_();
                        }
                    } else {
                        showNotification('❌ ' + (response.error || 'Ошибка'), 'error');
                        // Откат при ошибке
                        rollbackObjectUpdate_(objectId);
                    }
                })
                .catch(error => {
                    showNotification('❌ Ошибка соединения', 'error');
                    console.error('Action error:', error);
                    // Откат при ошибке
                    rollbackObjectUpdate_(objectId);
                });
        }
        
        /**
         * Оптимистично обновить объект в локальных данных
         * @private
         * @param {string|number} objectId - ID объекта
         * @param {string} action - Тип действия
         * @param {Object} params - Параметры
         */
        function optimisticallyUpdateObject_(objectId, action, params) {
            const object = DataState.findObjectById(objectId);
            if (!object) return;
            
            // Сохраняем оригинал для отката
            object._original = { ...object };
            
            const now = new Date().toISOString();
            let forceMapRerender = false;
            
            switch (action) {
                case 'entry':
                    object.entryTime = now;
                    break;
                case 'exit':
                    object.exitTime = now;
                    markCompletedTemporarilyVisible_(objectId);
                    break;
                case 'cancelEntry':
                    object.entryTime = null;
                    break;
                case 'denyAccess':
                    object.exitTime = 'нет';
                    break;
                case 'callLaboratory':
                    object.laboratory = true;
                    object.laboratoryComment = params.comment;
                    break;
                case 'reassign':
                    object.inspector = params.newInspector;
                    const reassignedStyle = getInspectorStyle(object.inspector);
                    applyLiveInspectorColorToMap_(object.inspector, reassignedStyle.color);
                    forceMapRerender = true;
                    break;
            }
            
            if (forceMapRerender) {
                MapState.setLastRenderSignature('');
            }
            // Обновляем карту
            scheduleMapUpdate_();
            
            // Если балун открыт - обновляем его содержимое
            if (UIState.getCurrentOpenObjectId() == objectId) {
                renderOpenObjectDetailsContent_(object);
            }
        }
        
        /**
         * Откатить изменения объекта при ошибке
         * @private
         * @param {string|number} objectId - ID объекта
         */
        function rollbackObjectUpdate_(objectId) {
            const object = DataState.findObjectById(objectId);
            if (object && object._original) {
                // Восстанавливаем оригинальные значения
                Object.assign(object, object._original);
                delete object._original;

                // Если оптимистичное завершение откатилось — убираем временную видимость
                if (!object.exitTime) {
                    FiltersState.clearRecentlyCompleted(objectId);
                }
                
                // Обновляем карту
                scheduleMapUpdate_();
                
                // Если балун открыт - обновляем содержимое
                if (UIState.getCurrentOpenObjectId() == objectId) {
                    renderOpenObjectDetailsContent_(object);
                }
            }
        }
        
        /**
         * Перезагрузить данные с сервера
         * @private
         */
        function reloadData_() {
            RuntimeState.clearDataLoadPromise();
            loadData().catch(err => console.error('Reload error:', err));
        }
        
        // ============================================
        // Публичный API модулей
        // ============================================

        const AppModules = Object.freeze({
            Filters: Object.freeze({
                renderFilterLists,
                updateMapFilters,
                toggleDivisionFilters,
                toggleOnlyActiveMode,
                toggleShowCompletedOnMap,
                applyStoredFiltersToUI: applyStoredFiltersToUI_,
                syncGroupCheckboxes: syncGroupCheckboxes_
            }),
            Map: Object.freeze({
                initMap,
                updateMap,
                showHomes,
                openObjectDetails,
                closeObjectDetails
            }),
            Objects: Object.freeze({
                switchNav,
                updateObjectsList,
                scheduleObjectsListUpdate: scheduleObjectsListUpdate_,
                refreshObjectsTabIfVisible: refreshObjectsTabIfVisible_,
                focusObjectFromObjectsTab: focusObjectFromObjectsTab_
            }),
            Customization: Object.freeze({
                showInspectorManagement,
                closeInspectorManagement,
                renderInspectorManagement,
                filterManagementInspectors,
                toggleInspectorCard,
                togglePicker,
                expandPickerOptions,
                selectColor,
                selectIcon,
                selectStatusOption,
                applyInspectorChanges
            })
        });
        window.AppModules = AppModules;

    </script>
</body>
</html>
